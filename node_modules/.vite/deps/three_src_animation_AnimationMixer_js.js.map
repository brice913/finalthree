{
  "version": 3,
  "sources": ["../../three/src/constants.js", "../../three/src/animation/AnimationAction.js", "../../three/src/core/EventDispatcher.js", "../../three/src/math/Interpolant.js", "../../three/src/math/interpolants/LinearInterpolant.js", "../../three/src/animation/PropertyBinding.js", "../../three/src/math/MathUtils.js", "../../three/src/math/Quaternion.js", "../../three/src/animation/PropertyMixer.js", "../../three/src/animation/AnimationUtils.js", "../../three/src/math/interpolants/CubicInterpolant.js", "../../three/src/math/interpolants/DiscreteInterpolant.js", "../../three/src/animation/KeyframeTrack.js", "../../three/src/animation/tracks/BooleanKeyframeTrack.js", "../../three/src/animation/tracks/ColorKeyframeTrack.js", "../../three/src/animation/tracks/NumberKeyframeTrack.js", "../../three/src/math/interpolants/QuaternionLinearInterpolant.js", "../../three/src/animation/tracks/QuaternionKeyframeTrack.js", "../../three/src/animation/tracks/StringKeyframeTrack.js", "../../three/src/animation/tracks/VectorKeyframeTrack.js", "../../three/src/animation/AnimationClip.js", "../../three/src/animation/AnimationMixer.js"],
  "sourcesContent": ["export const REVISION = '165';\n\nexport const MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 };\nexport const TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 };\nexport const CullFaceNone = 0;\nexport const CullFaceBack = 1;\nexport const CullFaceFront = 2;\nexport const CullFaceFrontBack = 3;\nexport const BasicShadowMap = 0;\nexport const PCFShadowMap = 1;\nexport const PCFSoftShadowMap = 2;\nexport const VSMShadowMap = 3;\nexport const FrontSide = 0;\nexport const BackSide = 1;\nexport const DoubleSide = 2;\nexport const NoBlending = 0;\nexport const NormalBlending = 1;\nexport const AdditiveBlending = 2;\nexport const SubtractiveBlending = 3;\nexport const MultiplyBlending = 4;\nexport const CustomBlending = 5;\nexport const AddEquation = 100;\nexport const SubtractEquation = 101;\nexport const ReverseSubtractEquation = 102;\nexport const MinEquation = 103;\nexport const MaxEquation = 104;\nexport const ZeroFactor = 200;\nexport const OneFactor = 201;\nexport const SrcColorFactor = 202;\nexport const OneMinusSrcColorFactor = 203;\nexport const SrcAlphaFactor = 204;\nexport const OneMinusSrcAlphaFactor = 205;\nexport const DstAlphaFactor = 206;\nexport const OneMinusDstAlphaFactor = 207;\nexport const DstColorFactor = 208;\nexport const OneMinusDstColorFactor = 209;\nexport const SrcAlphaSaturateFactor = 210;\nexport const ConstantColorFactor = 211;\nexport const OneMinusConstantColorFactor = 212;\nexport const ConstantAlphaFactor = 213;\nexport const OneMinusConstantAlphaFactor = 214;\nexport const NeverDepth = 0;\nexport const AlwaysDepth = 1;\nexport const LessDepth = 2;\nexport const LessEqualDepth = 3;\nexport const EqualDepth = 4;\nexport const GreaterEqualDepth = 5;\nexport const GreaterDepth = 6;\nexport const NotEqualDepth = 7;\nexport const MultiplyOperation = 0;\nexport const MixOperation = 1;\nexport const AddOperation = 2;\nexport const NoToneMapping = 0;\nexport const LinearToneMapping = 1;\nexport const ReinhardToneMapping = 2;\nexport const CineonToneMapping = 3;\nexport const ACESFilmicToneMapping = 4;\nexport const CustomToneMapping = 5;\nexport const AgXToneMapping = 6;\nexport const NeutralToneMapping = 7;\nexport const AttachedBindMode = 'attached';\nexport const DetachedBindMode = 'detached';\n\nexport const UVMapping = 300;\nexport const CubeReflectionMapping = 301;\nexport const CubeRefractionMapping = 302;\nexport const EquirectangularReflectionMapping = 303;\nexport const EquirectangularRefractionMapping = 304;\nexport const CubeUVReflectionMapping = 306;\nexport const RepeatWrapping = 1000;\nexport const ClampToEdgeWrapping = 1001;\nexport const MirroredRepeatWrapping = 1002;\nexport const NearestFilter = 1003;\nexport const NearestMipmapNearestFilter = 1004;\nexport const NearestMipMapNearestFilter = 1004;\nexport const NearestMipmapLinearFilter = 1005;\nexport const NearestMipMapLinearFilter = 1005;\nexport const LinearFilter = 1006;\nexport const LinearMipmapNearestFilter = 1007;\nexport const LinearMipMapNearestFilter = 1007;\nexport const LinearMipmapLinearFilter = 1008;\nexport const LinearMipMapLinearFilter = 1008;\nexport const UnsignedByteType = 1009;\nexport const ByteType = 1010;\nexport const ShortType = 1011;\nexport const UnsignedShortType = 1012;\nexport const IntType = 1013;\nexport const UnsignedIntType = 1014;\nexport const FloatType = 1015;\nexport const HalfFloatType = 1016;\nexport const UnsignedShort4444Type = 1017;\nexport const UnsignedShort5551Type = 1018;\nexport const UnsignedInt248Type = 1020;\nexport const UnsignedInt5999Type = 35902;\nexport const AlphaFormat = 1021;\nexport const RGBFormat = 1022;\nexport const RGBAFormat = 1023;\nexport const LuminanceFormat = 1024;\nexport const LuminanceAlphaFormat = 1025;\nexport const DepthFormat = 1026;\nexport const DepthStencilFormat = 1027;\nexport const RedFormat = 1028;\nexport const RedIntegerFormat = 1029;\nexport const RGFormat = 1030;\nexport const RGIntegerFormat = 1031;\nexport const RGBAIntegerFormat = 1033;\n\nexport const RGB_S3TC_DXT1_Format = 33776;\nexport const RGBA_S3TC_DXT1_Format = 33777;\nexport const RGBA_S3TC_DXT3_Format = 33778;\nexport const RGBA_S3TC_DXT5_Format = 33779;\nexport const RGB_PVRTC_4BPPV1_Format = 35840;\nexport const RGB_PVRTC_2BPPV1_Format = 35841;\nexport const RGBA_PVRTC_4BPPV1_Format = 35842;\nexport const RGBA_PVRTC_2BPPV1_Format = 35843;\nexport const RGB_ETC1_Format = 36196;\nexport const RGB_ETC2_Format = 37492;\nexport const RGBA_ETC2_EAC_Format = 37496;\nexport const RGBA_ASTC_4x4_Format = 37808;\nexport const RGBA_ASTC_5x4_Format = 37809;\nexport const RGBA_ASTC_5x5_Format = 37810;\nexport const RGBA_ASTC_6x5_Format = 37811;\nexport const RGBA_ASTC_6x6_Format = 37812;\nexport const RGBA_ASTC_8x5_Format = 37813;\nexport const RGBA_ASTC_8x6_Format = 37814;\nexport const RGBA_ASTC_8x8_Format = 37815;\nexport const RGBA_ASTC_10x5_Format = 37816;\nexport const RGBA_ASTC_10x6_Format = 37817;\nexport const RGBA_ASTC_10x8_Format = 37818;\nexport const RGBA_ASTC_10x10_Format = 37819;\nexport const RGBA_ASTC_12x10_Format = 37820;\nexport const RGBA_ASTC_12x12_Format = 37821;\nexport const RGBA_BPTC_Format = 36492;\nexport const RGB_BPTC_SIGNED_Format = 36494;\nexport const RGB_BPTC_UNSIGNED_Format = 36495;\nexport const RED_RGTC1_Format = 36283;\nexport const SIGNED_RED_RGTC1_Format = 36284;\nexport const RED_GREEN_RGTC2_Format = 36285;\nexport const SIGNED_RED_GREEN_RGTC2_Format = 36286;\nexport const LoopOnce = 2200;\nexport const LoopRepeat = 2201;\nexport const LoopPingPong = 2202;\nexport const InterpolateDiscrete = 2300;\nexport const InterpolateLinear = 2301;\nexport const InterpolateSmooth = 2302;\nexport const ZeroCurvatureEnding = 2400;\nexport const ZeroSlopeEnding = 2401;\nexport const WrapAroundEnding = 2402;\nexport const NormalAnimationBlendMode = 2500;\nexport const AdditiveAnimationBlendMode = 2501;\nexport const TrianglesDrawMode = 0;\nexport const TriangleStripDrawMode = 1;\nexport const TriangleFanDrawMode = 2;\nexport const BasicDepthPacking = 3200;\nexport const RGBADepthPacking = 3201;\nexport const TangentSpaceNormalMap = 0;\nexport const ObjectSpaceNormalMap = 1;\n\n// Color space string identifiers, matching CSS Color Module Level 4 and WebGPU names where available.\nexport const NoColorSpace = '';\nexport const SRGBColorSpace = 'srgb';\nexport const LinearSRGBColorSpace = 'srgb-linear';\nexport const DisplayP3ColorSpace = 'display-p3';\nexport const LinearDisplayP3ColorSpace = 'display-p3-linear';\n\nexport const LinearTransfer = 'linear';\nexport const SRGBTransfer = 'srgb';\n\nexport const Rec709Primaries = 'rec709';\nexport const P3Primaries = 'p3';\n\nexport const ZeroStencilOp = 0;\nexport const KeepStencilOp = 7680;\nexport const ReplaceStencilOp = 7681;\nexport const IncrementStencilOp = 7682;\nexport const DecrementStencilOp = 7683;\nexport const IncrementWrapStencilOp = 34055;\nexport const DecrementWrapStencilOp = 34056;\nexport const InvertStencilOp = 5386;\n\nexport const NeverStencilFunc = 512;\nexport const LessStencilFunc = 513;\nexport const EqualStencilFunc = 514;\nexport const LessEqualStencilFunc = 515;\nexport const GreaterStencilFunc = 516;\nexport const NotEqualStencilFunc = 517;\nexport const GreaterEqualStencilFunc = 518;\nexport const AlwaysStencilFunc = 519;\n\nexport const NeverCompare = 512;\nexport const LessCompare = 513;\nexport const EqualCompare = 514;\nexport const LessEqualCompare = 515;\nexport const GreaterCompare = 516;\nexport const NotEqualCompare = 517;\nexport const GreaterEqualCompare = 518;\nexport const AlwaysCompare = 519;\n\nexport const StaticDrawUsage = 35044;\nexport const DynamicDrawUsage = 35048;\nexport const StreamDrawUsage = 35040;\nexport const StaticReadUsage = 35045;\nexport const DynamicReadUsage = 35049;\nexport const StreamReadUsage = 35041;\nexport const StaticCopyUsage = 35046;\nexport const DynamicCopyUsage = 35050;\nexport const StreamCopyUsage = 35042;\n\nexport const GLSL1 = '100';\nexport const GLSL3 = '300 es';\n\nexport const WebGLCoordinateSystem = 2000;\nexport const WebGPUCoordinateSystem = 2001;\n", "import { WrapAroundEnding, ZeroCurvatureEnding, ZeroSlopeEnding, LoopPingPong, LoopOnce, LoopRepeat, NormalAnimationBlendMode, AdditiveAnimationBlendMode } from '../constants.js';\n\n\nclass AnimationAction {\n\n\tconstructor( mixer, clip, localRoot = null, blendMode = clip.blendMode ) {\n\n\t\tthis._mixer = mixer;\n\t\tthis._clip = clip;\n\t\tthis._localRoot = localRoot;\n\t\tthis.blendMode = blendMode;\n\n\t\tconst tracks = clip.tracks,\n\t\t\tnTracks = tracks.length,\n\t\t\tinterpolants = new Array( nTracks );\n\n\t\tconst interpolantSettings = {\n\t\t\tendingStart: ZeroCurvatureEnding,\n\t\t\tendingEnd: ZeroCurvatureEnding\n\t\t};\n\n\t\tfor ( let i = 0; i !== nTracks; ++ i ) {\n\n\t\t\tconst interpolant = tracks[ i ].createInterpolant( null );\n\t\t\tinterpolants[ i ] = interpolant;\n\t\t\tinterpolant.settings = interpolantSettings;\n\n\t\t}\n\n\t\tthis._interpolantSettings = interpolantSettings;\n\n\t\tthis._interpolants = interpolants; // bound by the mixer\n\n\t\t// inside: PropertyMixer (managed by the mixer)\n\t\tthis._propertyBindings = new Array( nTracks );\n\n\t\tthis._cacheIndex = null; // for the memory manager\n\t\tthis._byClipCacheIndex = null; // for the memory manager\n\n\t\tthis._timeScaleInterpolant = null;\n\t\tthis._weightInterpolant = null;\n\n\t\tthis.loop = LoopRepeat;\n\t\tthis._loopCount = - 1;\n\n\t\t// global mixer time when the action is to be started\n\t\t// it's set back to 'null' upon start of the action\n\t\tthis._startTime = null;\n\n\t\t// scaled local time of the action\n\t\t// gets clamped or wrapped to 0..clip.duration according to loop\n\t\tthis.time = 0;\n\n\t\tthis.timeScale = 1;\n\t\tthis._effectiveTimeScale = 1;\n\n\t\tthis.weight = 1;\n\t\tthis._effectiveWeight = 1;\n\n\t\tthis.repetitions = Infinity; // no. of repetitions when looping\n\n\t\tthis.paused = false; // true -> zero effective time scale\n\t\tthis.enabled = true; // false -> zero effective weight\n\n\t\tthis.clampWhenFinished = false;// keep feeding the last frame?\n\n\t\tthis.zeroSlopeAtStart = true;// for smooth interpolation w/o separate\n\t\tthis.zeroSlopeAtEnd = true;// clips for start, loop and end\n\n\t}\n\n\t// State & Scheduling\n\n\tplay() {\n\n\t\tthis._mixer._activateAction( this );\n\n\t\treturn this;\n\n\t}\n\n\tstop() {\n\n\t\tthis._mixer._deactivateAction( this );\n\n\t\treturn this.reset();\n\n\t}\n\n\treset() {\n\n\t\tthis.paused = false;\n\t\tthis.enabled = true;\n\n\t\tthis.time = 0; // restart clip\n\t\tthis._loopCount = - 1;// forget previous loops\n\t\tthis._startTime = null;// forget scheduling\n\n\t\treturn this.stopFading().stopWarping();\n\n\t}\n\n\tisRunning() {\n\n\t\treturn this.enabled && ! this.paused && this.timeScale !== 0 &&\n\t\t\tthis._startTime === null && this._mixer._isActiveAction( this );\n\n\t}\n\n\t// return true when play has been called\n\tisScheduled() {\n\n\t\treturn this._mixer._isActiveAction( this );\n\n\t}\n\n\tstartAt( time ) {\n\n\t\tthis._startTime = time;\n\n\t\treturn this;\n\n\t}\n\n\tsetLoop( mode, repetitions ) {\n\n\t\tthis.loop = mode;\n\t\tthis.repetitions = repetitions;\n\n\t\treturn this;\n\n\t}\n\n\t// Weight\n\n\t// set the weight stopping any scheduled fading\n\t// although .enabled = false yields an effective weight of zero, this\n\t// method does *not* change .enabled, because it would be confusing\n\tsetEffectiveWeight( weight ) {\n\n\t\tthis.weight = weight;\n\n\t\t// note: same logic as when updated at runtime\n\t\tthis._effectiveWeight = this.enabled ? weight : 0;\n\n\t\treturn this.stopFading();\n\n\t}\n\n\t// return the weight considering fading and .enabled\n\tgetEffectiveWeight() {\n\n\t\treturn this._effectiveWeight;\n\n\t}\n\n\tfadeIn( duration ) {\n\n\t\treturn this._scheduleFading( duration, 0, 1 );\n\n\t}\n\n\tfadeOut( duration ) {\n\n\t\treturn this._scheduleFading( duration, 1, 0 );\n\n\t}\n\n\tcrossFadeFrom( fadeOutAction, duration, warp ) {\n\n\t\tfadeOutAction.fadeOut( duration );\n\t\tthis.fadeIn( duration );\n\n\t\tif ( warp ) {\n\n\t\t\tconst fadeInDuration = this._clip.duration,\n\t\t\t\tfadeOutDuration = fadeOutAction._clip.duration,\n\n\t\t\t\tstartEndRatio = fadeOutDuration / fadeInDuration,\n\t\t\t\tendStartRatio = fadeInDuration / fadeOutDuration;\n\n\t\t\tfadeOutAction.warp( 1.0, startEndRatio, duration );\n\t\t\tthis.warp( endStartRatio, 1.0, duration );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tcrossFadeTo( fadeInAction, duration, warp ) {\n\n\t\treturn fadeInAction.crossFadeFrom( this, duration, warp );\n\n\t}\n\n\tstopFading() {\n\n\t\tconst weightInterpolant = this._weightInterpolant;\n\n\t\tif ( weightInterpolant !== null ) {\n\n\t\t\tthis._weightInterpolant = null;\n\t\t\tthis._mixer._takeBackControlInterpolant( weightInterpolant );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// Time Scale Control\n\n\t// set the time scale stopping any scheduled warping\n\t// although .paused = true yields an effective time scale of zero, this\n\t// method does *not* change .paused, because it would be confusing\n\tsetEffectiveTimeScale( timeScale ) {\n\n\t\tthis.timeScale = timeScale;\n\t\tthis._effectiveTimeScale = this.paused ? 0 : timeScale;\n\n\t\treturn this.stopWarping();\n\n\t}\n\n\t// return the time scale considering warping and .paused\n\tgetEffectiveTimeScale() {\n\n\t\treturn this._effectiveTimeScale;\n\n\t}\n\n\tsetDuration( duration ) {\n\n\t\tthis.timeScale = this._clip.duration / duration;\n\n\t\treturn this.stopWarping();\n\n\t}\n\n\tsyncWith( action ) {\n\n\t\tthis.time = action.time;\n\t\tthis.timeScale = action.timeScale;\n\n\t\treturn this.stopWarping();\n\n\t}\n\n\thalt( duration ) {\n\n\t\treturn this.warp( this._effectiveTimeScale, 0, duration );\n\n\t}\n\n\twarp( startTimeScale, endTimeScale, duration ) {\n\n\t\tconst mixer = this._mixer,\n\t\t\tnow = mixer.time,\n\t\t\ttimeScale = this.timeScale;\n\n\t\tlet interpolant = this._timeScaleInterpolant;\n\n\t\tif ( interpolant === null ) {\n\n\t\t\tinterpolant = mixer._lendControlInterpolant();\n\t\t\tthis._timeScaleInterpolant = interpolant;\n\n\t\t}\n\n\t\tconst times = interpolant.parameterPositions,\n\t\t\tvalues = interpolant.sampleValues;\n\n\t\ttimes[ 0 ] = now;\n\t\ttimes[ 1 ] = now + duration;\n\n\t\tvalues[ 0 ] = startTimeScale / timeScale;\n\t\tvalues[ 1 ] = endTimeScale / timeScale;\n\n\t\treturn this;\n\n\t}\n\n\tstopWarping() {\n\n\t\tconst timeScaleInterpolant = this._timeScaleInterpolant;\n\n\t\tif ( timeScaleInterpolant !== null ) {\n\n\t\t\tthis._timeScaleInterpolant = null;\n\t\t\tthis._mixer._takeBackControlInterpolant( timeScaleInterpolant );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// Object Accessors\n\n\tgetMixer() {\n\n\t\treturn this._mixer;\n\n\t}\n\n\tgetClip() {\n\n\t\treturn this._clip;\n\n\t}\n\n\tgetRoot() {\n\n\t\treturn this._localRoot || this._mixer._root;\n\n\t}\n\n\t// Interna\n\n\t_update( time, deltaTime, timeDirection, accuIndex ) {\n\n\t\t// called by the mixer\n\n\t\tif ( ! this.enabled ) {\n\n\t\t\t// call ._updateWeight() to update ._effectiveWeight\n\n\t\t\tthis._updateWeight( time );\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst startTime = this._startTime;\n\n\t\tif ( startTime !== null ) {\n\n\t\t\t// check for scheduled start of action\n\n\t\t\tconst timeRunning = ( time - startTime ) * timeDirection;\n\t\t\tif ( timeRunning < 0 || timeDirection === 0 ) {\n\n\t\t\t\tdeltaTime = 0;\n\n\t\t\t} else {\n\n\n\t\t\t\tthis._startTime = null; // unschedule\n\t\t\t\tdeltaTime = timeDirection * timeRunning;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// apply time scale and advance time\n\n\t\tdeltaTime *= this._updateTimeScale( time );\n\t\tconst clipTime = this._updateTime( deltaTime );\n\n\t\t// note: _updateTime may disable the action resulting in\n\t\t// an effective weight of 0\n\n\t\tconst weight = this._updateWeight( time );\n\n\t\tif ( weight > 0 ) {\n\n\t\t\tconst interpolants = this._interpolants;\n\t\t\tconst propertyMixers = this._propertyBindings;\n\n\t\t\tswitch ( this.blendMode ) {\n\n\t\t\t\tcase AdditiveAnimationBlendMode:\n\n\t\t\t\t\tfor ( let j = 0, m = interpolants.length; j !== m; ++ j ) {\n\n\t\t\t\t\t\tinterpolants[ j ].evaluate( clipTime );\n\t\t\t\t\t\tpropertyMixers[ j ].accumulateAdditive( weight );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase NormalAnimationBlendMode:\n\t\t\t\tdefault:\n\n\t\t\t\t\tfor ( let j = 0, m = interpolants.length; j !== m; ++ j ) {\n\n\t\t\t\t\t\tinterpolants[ j ].evaluate( clipTime );\n\t\t\t\t\t\tpropertyMixers[ j ].accumulate( accuIndex, weight );\n\n\t\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_updateWeight( time ) {\n\n\t\tlet weight = 0;\n\n\t\tif ( this.enabled ) {\n\n\t\t\tweight = this.weight;\n\t\t\tconst interpolant = this._weightInterpolant;\n\n\t\t\tif ( interpolant !== null ) {\n\n\t\t\t\tconst interpolantValue = interpolant.evaluate( time )[ 0 ];\n\n\t\t\t\tweight *= interpolantValue;\n\n\t\t\t\tif ( time > interpolant.parameterPositions[ 1 ] ) {\n\n\t\t\t\t\tthis.stopFading();\n\n\t\t\t\t\tif ( interpolantValue === 0 ) {\n\n\t\t\t\t\t\t// faded out, disable\n\t\t\t\t\t\tthis.enabled = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis._effectiveWeight = weight;\n\t\treturn weight;\n\n\t}\n\n\t_updateTimeScale( time ) {\n\n\t\tlet timeScale = 0;\n\n\t\tif ( ! this.paused ) {\n\n\t\t\ttimeScale = this.timeScale;\n\n\t\t\tconst interpolant = this._timeScaleInterpolant;\n\n\t\t\tif ( interpolant !== null ) {\n\n\t\t\t\tconst interpolantValue = interpolant.evaluate( time )[ 0 ];\n\n\t\t\t\ttimeScale *= interpolantValue;\n\n\t\t\t\tif ( time > interpolant.parameterPositions[ 1 ] ) {\n\n\t\t\t\t\tthis.stopWarping();\n\n\t\t\t\t\tif ( timeScale === 0 ) {\n\n\t\t\t\t\t\t// motion has halted, pause\n\t\t\t\t\t\tthis.paused = true;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// warp done - apply final time scale\n\t\t\t\t\t\tthis.timeScale = timeScale;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis._effectiveTimeScale = timeScale;\n\t\treturn timeScale;\n\n\t}\n\n\t_updateTime( deltaTime ) {\n\n\t\tconst duration = this._clip.duration;\n\t\tconst loop = this.loop;\n\n\t\tlet time = this.time + deltaTime;\n\t\tlet loopCount = this._loopCount;\n\n\t\tconst pingPong = ( loop === LoopPingPong );\n\n\t\tif ( deltaTime === 0 ) {\n\n\t\t\tif ( loopCount === - 1 ) return time;\n\n\t\t\treturn ( pingPong && ( loopCount & 1 ) === 1 ) ? duration - time : time;\n\n\t\t}\n\n\t\tif ( loop === LoopOnce ) {\n\n\t\t\tif ( loopCount === - 1 ) {\n\n\t\t\t\t// just started\n\n\t\t\t\tthis._loopCount = 0;\n\t\t\t\tthis._setEndings( true, true, false );\n\n\t\t\t}\n\n\t\t\thandle_stop: {\n\n\t\t\t\tif ( time >= duration ) {\n\n\t\t\t\t\ttime = duration;\n\n\t\t\t\t} else if ( time < 0 ) {\n\n\t\t\t\t\ttime = 0;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.time = time;\n\n\t\t\t\t\tbreak handle_stop;\n\n\t\t\t\t}\n\n\t\t\t\tif ( this.clampWhenFinished ) this.paused = true;\n\t\t\t\telse this.enabled = false;\n\n\t\t\t\tthis.time = time;\n\n\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\ttype: 'finished', action: this,\n\t\t\t\t\tdirection: deltaTime < 0 ? - 1 : 1\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t} else { // repetitive Repeat or PingPong\n\n\t\t\tif ( loopCount === - 1 ) {\n\n\t\t\t\t// just started\n\n\t\t\t\tif ( deltaTime >= 0 ) {\n\n\t\t\t\t\tloopCount = 0;\n\n\t\t\t\t\tthis._setEndings( true, this.repetitions === 0, pingPong );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// when looping in reverse direction, the initial\n\t\t\t\t\t// transition through zero counts as a repetition,\n\t\t\t\t\t// so leave loopCount at -1\n\n\t\t\t\t\tthis._setEndings( this.repetitions === 0, true, pingPong );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( time >= duration || time < 0 ) {\n\n\t\t\t\t// wrap around\n\n\t\t\t\tconst loopDelta = Math.floor( time / duration ); // signed\n\t\t\t\ttime -= duration * loopDelta;\n\n\t\t\t\tloopCount += Math.abs( loopDelta );\n\n\t\t\t\tconst pending = this.repetitions - loopCount;\n\n\t\t\t\tif ( pending <= 0 ) {\n\n\t\t\t\t\t// have to stop (switch state, clamp time, fire event)\n\n\t\t\t\t\tif ( this.clampWhenFinished ) this.paused = true;\n\t\t\t\t\telse this.enabled = false;\n\n\t\t\t\t\ttime = deltaTime > 0 ? duration : 0;\n\n\t\t\t\t\tthis.time = time;\n\n\t\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\t\ttype: 'finished', action: this,\n\t\t\t\t\t\tdirection: deltaTime > 0 ? 1 : - 1\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// keep running\n\n\t\t\t\t\tif ( pending === 1 ) {\n\n\t\t\t\t\t\t// entering the last round\n\n\t\t\t\t\t\tconst atStart = deltaTime < 0;\n\t\t\t\t\t\tthis._setEndings( atStart, ! atStart, pingPong );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis._setEndings( false, false, pingPong );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._loopCount = loopCount;\n\n\t\t\t\t\tthis.time = time;\n\n\t\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\t\ttype: 'loop', action: this, loopDelta: loopDelta\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tthis.time = time;\n\n\t\t\t}\n\n\t\t\tif ( pingPong && ( loopCount & 1 ) === 1 ) {\n\n\t\t\t\t// invert time for the \"pong round\"\n\n\t\t\t\treturn duration - time;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn time;\n\n\t}\n\n\t_setEndings( atStart, atEnd, pingPong ) {\n\n\t\tconst settings = this._interpolantSettings;\n\n\t\tif ( pingPong ) {\n\n\t\t\tsettings.endingStart = ZeroSlopeEnding;\n\t\t\tsettings.endingEnd = ZeroSlopeEnding;\n\n\t\t} else {\n\n\t\t\t// assuming for LoopOnce atStart == atEnd == true\n\n\t\t\tif ( atStart ) {\n\n\t\t\t\tsettings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;\n\n\t\t\t} else {\n\n\t\t\t\tsettings.endingStart = WrapAroundEnding;\n\n\t\t\t}\n\n\t\t\tif ( atEnd ) {\n\n\t\t\t\tsettings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;\n\n\t\t\t} else {\n\n\t\t\t\tsettings.endingEnd \t = WrapAroundEnding;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_scheduleFading( duration, weightNow, weightThen ) {\n\n\t\tconst mixer = this._mixer, now = mixer.time;\n\t\tlet interpolant = this._weightInterpolant;\n\n\t\tif ( interpolant === null ) {\n\n\t\t\tinterpolant = mixer._lendControlInterpolant();\n\t\t\tthis._weightInterpolant = interpolant;\n\n\t\t}\n\n\t\tconst times = interpolant.parameterPositions,\n\t\t\tvalues = interpolant.sampleValues;\n\n\t\ttimes[ 0 ] = now;\n\t\tvalues[ 0 ] = weightNow;\n\t\ttimes[ 1 ] = now + duration;\n\t\tvalues[ 1 ] = weightThen;\n\n\t\treturn this;\n\n\t}\n\n}\n\n\nexport { AnimationAction };\n", "/**\n * https://github.com/mrdoob/eventdispatcher.js/\n */\n\nclass EventDispatcher {\n\n\taddEventListener( type, listener ) {\n\n\t\tif ( this._listeners === undefined ) this._listeners = {};\n\n\t\tconst listeners = this._listeners;\n\n\t\tif ( listeners[ type ] === undefined ) {\n\n\t\t\tlisteners[ type ] = [];\n\n\t\t}\n\n\t\tif ( listeners[ type ].indexOf( listener ) === - 1 ) {\n\n\t\t\tlisteners[ type ].push( listener );\n\n\t\t}\n\n\t}\n\n\thasEventListener( type, listener ) {\n\n\t\tif ( this._listeners === undefined ) return false;\n\n\t\tconst listeners = this._listeners;\n\n\t\treturn listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;\n\n\t}\n\n\tremoveEventListener( type, listener ) {\n\n\t\tif ( this._listeners === undefined ) return;\n\n\t\tconst listeners = this._listeners;\n\t\tconst listenerArray = listeners[ type ];\n\n\t\tif ( listenerArray !== undefined ) {\n\n\t\t\tconst index = listenerArray.indexOf( listener );\n\n\t\t\tif ( index !== - 1 ) {\n\n\t\t\t\tlistenerArray.splice( index, 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tdispatchEvent( event ) {\n\n\t\tif ( this._listeners === undefined ) return;\n\n\t\tconst listeners = this._listeners;\n\t\tconst listenerArray = listeners[ event.type ];\n\n\t\tif ( listenerArray !== undefined ) {\n\n\t\t\tevent.target = this;\n\n\t\t\t// Make a copy, in case listeners are removed while iterating.\n\t\t\tconst array = listenerArray.slice( 0 );\n\n\t\t\tfor ( let i = 0, l = array.length; i < l; i ++ ) {\n\n\t\t\t\tarray[ i ].call( this, event );\n\n\t\t\t}\n\n\t\t\tevent.target = null;\n\n\t\t}\n\n\t}\n\n}\n\n\nexport { EventDispatcher };\n", "/**\n * Abstract base class of interpolants over parametric samples.\n *\n * The parameter domain is one dimensional, typically the time or a path\n * along a curve defined by the data.\n *\n * The sample values can have any dimensionality and derived classes may\n * apply special interpretations to the data.\n *\n * This class provides the interval seek in a Template Method, deferring\n * the actual interpolation to derived classes.\n *\n * Time complexity is O(1) for linear access crossing at most two points\n * and O(log N) for random access, where N is the number of positions.\n *\n * References:\n *\n * \t\thttp://www.oodesign.com/template-method-pattern.html\n *\n */\n\nclass Interpolant {\n\n\tconstructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tthis.parameterPositions = parameterPositions;\n\t\tthis._cachedIndex = 0;\n\n\t\tthis.resultBuffer = resultBuffer !== undefined ?\n\t\t\tresultBuffer : new sampleValues.constructor( sampleSize );\n\t\tthis.sampleValues = sampleValues;\n\t\tthis.valueSize = sampleSize;\n\n\t\tthis.settings = null;\n\t\tthis.DefaultSettings_ = {};\n\n\t}\n\n\tevaluate( t ) {\n\n\t\tconst pp = this.parameterPositions;\n\t\tlet i1 = this._cachedIndex,\n\t\t\tt1 = pp[ i1 ],\n\t\t\tt0 = pp[ i1 - 1 ];\n\n\t\tvalidate_interval: {\n\n\t\t\tseek: {\n\n\t\t\t\tlet right;\n\n\t\t\t\tlinear_scan: {\n\n\t\t\t\t\t//- See http://jsperf.com/comparison-to-undefined/3\n\t\t\t\t\t//- slower code:\n\t\t\t\t\t//-\n\t\t\t\t\t//- \t\t\t\tif ( t >= t1 || t1 === undefined ) {\n\t\t\t\t\tforward_scan: if ( ! ( t < t1 ) ) {\n\n\t\t\t\t\t\tfor ( let giveUpAt = i1 + 2; ; ) {\n\n\t\t\t\t\t\t\tif ( t1 === undefined ) {\n\n\t\t\t\t\t\t\t\tif ( t < t0 ) break forward_scan;\n\n\t\t\t\t\t\t\t\t// after end\n\n\t\t\t\t\t\t\t\ti1 = pp.length;\n\t\t\t\t\t\t\t\tthis._cachedIndex = i1;\n\t\t\t\t\t\t\t\treturn this.copySampleValue_( i1 - 1 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( i1 === giveUpAt ) break; // this loop\n\n\t\t\t\t\t\t\tt0 = t1;\n\t\t\t\t\t\t\tt1 = pp[ ++ i1 ];\n\n\t\t\t\t\t\t\tif ( t < t1 ) {\n\n\t\t\t\t\t\t\t\t// we have arrived at the sought interval\n\t\t\t\t\t\t\t\tbreak seek;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// prepare binary search on the right side of the index\n\t\t\t\t\t\tright = pp.length;\n\t\t\t\t\t\tbreak linear_scan;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t//- slower code:\n\t\t\t\t\t//-\t\t\t\t\tif ( t < t0 || t0 === undefined ) {\n\t\t\t\t\tif ( ! ( t >= t0 ) ) {\n\n\t\t\t\t\t\t// looping?\n\n\t\t\t\t\t\tconst t1global = pp[ 1 ];\n\n\t\t\t\t\t\tif ( t < t1global ) {\n\n\t\t\t\t\t\t\ti1 = 2; // + 1, using the scan for the details\n\t\t\t\t\t\t\tt0 = t1global;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// linear reverse scan\n\n\t\t\t\t\t\tfor ( let giveUpAt = i1 - 2; ; ) {\n\n\t\t\t\t\t\t\tif ( t0 === undefined ) {\n\n\t\t\t\t\t\t\t\t// before start\n\n\t\t\t\t\t\t\t\tthis._cachedIndex = 0;\n\t\t\t\t\t\t\t\treturn this.copySampleValue_( 0 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( i1 === giveUpAt ) break; // this loop\n\n\t\t\t\t\t\t\tt1 = t0;\n\t\t\t\t\t\t\tt0 = pp[ -- i1 - 1 ];\n\n\t\t\t\t\t\t\tif ( t >= t0 ) {\n\n\t\t\t\t\t\t\t\t// we have arrived at the sought interval\n\t\t\t\t\t\t\t\tbreak seek;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// prepare binary search on the left side of the index\n\t\t\t\t\t\tright = i1;\n\t\t\t\t\t\ti1 = 0;\n\t\t\t\t\t\tbreak linear_scan;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// the interval is valid\n\n\t\t\t\t\tbreak validate_interval;\n\n\t\t\t\t} // linear scan\n\n\t\t\t\t// binary search\n\n\t\t\t\twhile ( i1 < right ) {\n\n\t\t\t\t\tconst mid = ( i1 + right ) >>> 1;\n\n\t\t\t\t\tif ( t < pp[ mid ] ) {\n\n\t\t\t\t\t\tright = mid;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ti1 = mid + 1;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tt1 = pp[ i1 ];\n\t\t\t\tt0 = pp[ i1 - 1 ];\n\n\t\t\t\t// check boundary cases, again\n\n\t\t\t\tif ( t0 === undefined ) {\n\n\t\t\t\t\tthis._cachedIndex = 0;\n\t\t\t\t\treturn this.copySampleValue_( 0 );\n\n\t\t\t\t}\n\n\t\t\t\tif ( t1 === undefined ) {\n\n\t\t\t\t\ti1 = pp.length;\n\t\t\t\t\tthis._cachedIndex = i1;\n\t\t\t\t\treturn this.copySampleValue_( i1 - 1 );\n\n\t\t\t\t}\n\n\t\t\t} // seek\n\n\t\t\tthis._cachedIndex = i1;\n\n\t\t\tthis.intervalChanged_( i1, t0, t1 );\n\n\t\t} // validate_interval\n\n\t\treturn this.interpolate_( i1, t0, t, t1 );\n\n\t}\n\n\tgetSettings_() {\n\n\t\treturn this.settings || this.DefaultSettings_;\n\n\t}\n\n\tcopySampleValue_( index ) {\n\n\t\t// copies a sample value to the result buffer\n\n\t\tconst result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tstride = this.valueSize,\n\t\t\toffset = index * stride;\n\n\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\tresult[ i ] = values[ offset + i ];\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\t// Template methods for derived classes:\n\n\tinterpolate_( /* i1, t0, t, t1 */ ) {\n\n\t\tthrow new Error( 'call to abstract method' );\n\t\t// implementations shall return this.resultBuffer\n\n\t}\n\n\tintervalChanged_( /* i1, t0, t1 */ ) {\n\n\t\t// empty\n\n\t}\n\n}\n\nexport { Interpolant };\n", "import { Interpolant } from '../Interpolant.js';\n\nclass LinearInterpolant extends Interpolant {\n\n\tconstructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tsuper( parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\t}\n\n\tinterpolate_( i1, t0, t, t1 ) {\n\n\t\tconst result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tstride = this.valueSize,\n\n\t\t\toffset1 = i1 * stride,\n\t\t\toffset0 = offset1 - stride,\n\n\t\t\tweight1 = ( t - t0 ) / ( t1 - t0 ),\n\t\t\tweight0 = 1 - weight1;\n\n\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\tresult[ i ] =\n\t\t\t\t\tvalues[ offset0 + i ] * weight0 +\n\t\t\t\t\tvalues[ offset1 + i ] * weight1;\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n}\n\n\nexport { LinearInterpolant };\n", "// Characters [].:/ are reserved for track binding syntax.\nconst _RESERVED_CHARS_RE = '\\\\[\\\\]\\\\.:\\\\/';\nconst _reservedRe = new RegExp( '[' + _RESERVED_CHARS_RE + ']', 'g' );\n\n// Attempts to allow node names from any language. ES5's `\\w` regexp matches\n// only latin characters, and the unicode \\p{L} is not yet supported. So\n// instead, we exclude reserved characters and match everything else.\nconst _wordChar = '[^' + _RESERVED_CHARS_RE + ']';\nconst _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace( '\\\\.', '' ) + ']';\n\n// Parent directories, delimited by '/' or ':'. Currently unused, but must\n// be matched to parse the rest of the track name.\nconst _directoryRe = /*@__PURE__*/ /((?:WC+[\\/:])*)/.source.replace( 'WC', _wordChar );\n\n// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.\nconst _nodeRe = /*@__PURE__*/ /(WCOD+)?/.source.replace( 'WCOD', _wordCharOrDot );\n\n// Object on target node, and accessor. May not contain reserved\n// characters. Accessor may contain any character except closing bracket.\nconst _objectRe = /*@__PURE__*/ /(?:\\.(WC+)(?:\\[(.+)\\])?)?/.source.replace( 'WC', _wordChar );\n\n// Property and accessor. May not contain reserved characters. Accessor may\n// contain any non-bracket characters.\nconst _propertyRe = /*@__PURE__*/ /\\.(WC+)(?:\\[(.+)\\])?/.source.replace( 'WC', _wordChar );\n\nconst _trackRe = new RegExp( ''\n\t+ '^'\n\t+ _directoryRe\n\t+ _nodeRe\n\t+ _objectRe\n\t+ _propertyRe\n\t+ '$'\n);\n\nconst _supportedObjectNames = [ 'material', 'materials', 'bones', 'map' ];\n\nclass Composite {\n\n\tconstructor( targetGroup, path, optionalParsedPath ) {\n\n\t\tconst parsedPath = optionalParsedPath || PropertyBinding.parseTrackName( path );\n\n\t\tthis._targetGroup = targetGroup;\n\t\tthis._bindings = targetGroup.subscribe_( path, parsedPath );\n\n\t}\n\n\tgetValue( array, offset ) {\n\n\t\tthis.bind(); // bind all binding\n\n\t\tconst firstValidIndex = this._targetGroup.nCachedObjects_,\n\t\t\tbinding = this._bindings[ firstValidIndex ];\n\n\t\t// and only call .getValue on the first\n\t\tif ( binding !== undefined ) binding.getValue( array, offset );\n\n\t}\n\n\tsetValue( array, offset ) {\n\n\t\tconst bindings = this._bindings;\n\n\t\tfor ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\tbindings[ i ].setValue( array, offset );\n\n\t\t}\n\n\t}\n\n\tbind() {\n\n\t\tconst bindings = this._bindings;\n\n\t\tfor ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\tbindings[ i ].bind();\n\n\t\t}\n\n\t}\n\n\tunbind() {\n\n\t\tconst bindings = this._bindings;\n\n\t\tfor ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\tbindings[ i ].unbind();\n\n\t\t}\n\n\t}\n\n}\n\n// Note: This class uses a State pattern on a per-method basis:\n// 'bind' sets 'this.getValue' / 'setValue' and shadows the\n// prototype version of these methods with one that represents\n// the bound state. When the property is not found, the methods\n// become no-ops.\nclass PropertyBinding {\n\n\tconstructor( rootNode, path, parsedPath ) {\n\n\t\tthis.path = path;\n\t\tthis.parsedPath = parsedPath || PropertyBinding.parseTrackName( path );\n\n\t\tthis.node = PropertyBinding.findNode( rootNode, this.parsedPath.nodeName );\n\n\t\tthis.rootNode = rootNode;\n\n\t\t// initial state of these methods that calls 'bind'\n\t\tthis.getValue = this._getValue_unbound;\n\t\tthis.setValue = this._setValue_unbound;\n\n\t}\n\n\n\tstatic create( root, path, parsedPath ) {\n\n\t\tif ( ! ( root && root.isAnimationObjectGroup ) ) {\n\n\t\t\treturn new PropertyBinding( root, path, parsedPath );\n\n\t\t} else {\n\n\t\t\treturn new PropertyBinding.Composite( root, path, parsedPath );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Replaces spaces with underscores and removes unsupported characters from\n\t * node names, to ensure compatibility with parseTrackName().\n\t *\n\t * @param {string} name Node name to be sanitized.\n\t * @return {string}\n\t */\n\tstatic sanitizeNodeName( name ) {\n\n\t\treturn name.replace( /\\s/g, '_' ).replace( _reservedRe, '' );\n\n\t}\n\n\tstatic parseTrackName( trackName ) {\n\n\t\tconst matches = _trackRe.exec( trackName );\n\n\t\tif ( matches === null ) {\n\n\t\t\tthrow new Error( 'PropertyBinding: Cannot parse trackName: ' + trackName );\n\n\t\t}\n\n\t\tconst results = {\n\t\t\t// directoryName: matches[ 1 ], // (tschw) currently unused\n\t\t\tnodeName: matches[ 2 ],\n\t\t\tobjectName: matches[ 3 ],\n\t\t\tobjectIndex: matches[ 4 ],\n\t\t\tpropertyName: matches[ 5 ], // required\n\t\t\tpropertyIndex: matches[ 6 ]\n\t\t};\n\n\t\tconst lastDot = results.nodeName && results.nodeName.lastIndexOf( '.' );\n\n\t\tif ( lastDot !== undefined && lastDot !== - 1 ) {\n\n\t\t\tconst objectName = results.nodeName.substring( lastDot + 1 );\n\n\t\t\t// Object names must be checked against an allowlist. Otherwise, there\n\t\t\t// is no way to parse 'foo.bar.baz': 'baz' must be a property, but\n\t\t\t// 'bar' could be the objectName, or part of a nodeName (which can\n\t\t\t// include '.' characters).\n\t\t\tif ( _supportedObjectNames.indexOf( objectName ) !== - 1 ) {\n\n\t\t\t\tresults.nodeName = results.nodeName.substring( 0, lastDot );\n\t\t\t\tresults.objectName = objectName;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( results.propertyName === null || results.propertyName.length === 0 ) {\n\n\t\t\tthrow new Error( 'PropertyBinding: can not parse propertyName from trackName: ' + trackName );\n\n\t\t}\n\n\t\treturn results;\n\n\t}\n\n\tstatic findNode( root, nodeName ) {\n\n\t\tif ( nodeName === undefined || nodeName === '' || nodeName === '.' || nodeName === - 1 || nodeName === root.name || nodeName === root.uuid ) {\n\n\t\t\treturn root;\n\n\t\t}\n\n\t\t// search into skeleton bones.\n\t\tif ( root.skeleton ) {\n\n\t\t\tconst bone = root.skeleton.getBoneByName( nodeName );\n\n\t\t\tif ( bone !== undefined ) {\n\n\t\t\t\treturn bone;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// search into node subtree.\n\t\tif ( root.children ) {\n\n\t\t\tconst searchNodeSubtree = function ( children ) {\n\n\t\t\t\tfor ( let i = 0; i < children.length; i ++ ) {\n\n\t\t\t\t\tconst childNode = children[ i ];\n\n\t\t\t\t\tif ( childNode.name === nodeName || childNode.uuid === nodeName ) {\n\n\t\t\t\t\t\treturn childNode;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst result = searchNodeSubtree( childNode.children );\n\n\t\t\t\t\tif ( result ) return result;\n\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\n\t\t\t};\n\n\t\t\tconst subTreeNode = searchNodeSubtree( root.children );\n\n\t\t\tif ( subTreeNode ) {\n\n\t\t\t\treturn subTreeNode;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\t// these are used to \"bind\" a nonexistent property\n\t_getValue_unavailable() {}\n\t_setValue_unavailable() {}\n\n\t// Getters\n\n\t_getValue_direct( buffer, offset ) {\n\n\t\tbuffer[ offset ] = this.targetObject[ this.propertyName ];\n\n\t}\n\n\t_getValue_array( buffer, offset ) {\n\n\t\tconst source = this.resolvedProperty;\n\n\t\tfor ( let i = 0, n = source.length; i !== n; ++ i ) {\n\n\t\t\tbuffer[ offset ++ ] = source[ i ];\n\n\t\t}\n\n\t}\n\n\t_getValue_arrayElement( buffer, offset ) {\n\n\t\tbuffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];\n\n\t}\n\n\t_getValue_toArray( buffer, offset ) {\n\n\t\tthis.resolvedProperty.toArray( buffer, offset );\n\n\t}\n\n\t// Direct\n\n\t_setValue_direct( buffer, offset ) {\n\n\t\tthis.targetObject[ this.propertyName ] = buffer[ offset ];\n\n\t}\n\n\t_setValue_direct_setNeedsUpdate( buffer, offset ) {\n\n\t\tthis.targetObject[ this.propertyName ] = buffer[ offset ];\n\t\tthis.targetObject.needsUpdate = true;\n\n\t}\n\n\t_setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\tthis.targetObject[ this.propertyName ] = buffer[ offset ];\n\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t}\n\n\t// EntireArray\n\n\t_setValue_array( buffer, offset ) {\n\n\t\tconst dest = this.resolvedProperty;\n\n\t\tfor ( let i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t}\n\n\t}\n\n\t_setValue_array_setNeedsUpdate( buffer, offset ) {\n\n\t\tconst dest = this.resolvedProperty;\n\n\t\tfor ( let i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t}\n\n\t\tthis.targetObject.needsUpdate = true;\n\n\t}\n\n\t_setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\tconst dest = this.resolvedProperty;\n\n\t\tfor ( let i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t}\n\n\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t}\n\n\t// ArrayElement\n\n\t_setValue_arrayElement( buffer, offset ) {\n\n\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\n\t}\n\n\t_setValue_arrayElement_setNeedsUpdate( buffer, offset ) {\n\n\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\t\tthis.targetObject.needsUpdate = true;\n\n\t}\n\n\t_setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t}\n\n\t// HasToFromArray\n\n\t_setValue_fromArray( buffer, offset ) {\n\n\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\n\t}\n\n\t_setValue_fromArray_setNeedsUpdate( buffer, offset ) {\n\n\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\t\tthis.targetObject.needsUpdate = true;\n\n\t}\n\n\t_setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t}\n\n\t_getValue_unbound( targetArray, offset ) {\n\n\t\tthis.bind();\n\t\tthis.getValue( targetArray, offset );\n\n\t}\n\n\t_setValue_unbound( sourceArray, offset ) {\n\n\t\tthis.bind();\n\t\tthis.setValue( sourceArray, offset );\n\n\t}\n\n\t// create getter / setter pair for a property in the scene graph\n\tbind() {\n\n\t\tlet targetObject = this.node;\n\t\tconst parsedPath = this.parsedPath;\n\n\t\tconst objectName = parsedPath.objectName;\n\t\tconst propertyName = parsedPath.propertyName;\n\t\tlet propertyIndex = parsedPath.propertyIndex;\n\n\t\tif ( ! targetObject ) {\n\n\t\t\ttargetObject = PropertyBinding.findNode( this.rootNode, parsedPath.nodeName );\n\n\t\t\tthis.node = targetObject;\n\n\t\t}\n\n\t\t// set fail state so we can just 'return' on error\n\t\tthis.getValue = this._getValue_unavailable;\n\t\tthis.setValue = this._setValue_unavailable;\n\n\t\t// ensure there is a value node\n\t\tif ( ! targetObject ) {\n\n\t\t\tconsole.warn( 'THREE.PropertyBinding: No target node found for track: ' + this.path + '.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( objectName ) {\n\n\t\t\tlet objectIndex = parsedPath.objectIndex;\n\n\t\t\t// special cases were we need to reach deeper into the hierarchy to get the face materials....\n\t\t\tswitch ( objectName ) {\n\n\t\t\t\tcase 'materials':\n\n\t\t\t\t\tif ( ! targetObject.material ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! targetObject.material.materials ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttargetObject = targetObject.material.materials;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'bones':\n\n\t\t\t\t\tif ( ! targetObject.skeleton ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// potential future optimization: skip this if propertyIndex is already an integer\n\t\t\t\t\t// and convert the integer string to a true integer.\n\n\t\t\t\t\ttargetObject = targetObject.skeleton.bones;\n\n\t\t\t\t\t// support resolving morphTarget names into indices.\n\t\t\t\t\tfor ( let i = 0; i < targetObject.length; i ++ ) {\n\n\t\t\t\t\t\tif ( targetObject[ i ].name === objectIndex ) {\n\n\t\t\t\t\t\t\tobjectIndex = i;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'map':\n\n\t\t\t\t\tif ( 'map' in targetObject ) {\n\n\t\t\t\t\t\ttargetObject = targetObject.map;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! targetObject.material ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! targetObject.material.map ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttargetObject = targetObject.material.map;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tif ( targetObject[ objectName ] === undefined ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to objectName of node undefined.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttargetObject = targetObject[ objectName ];\n\n\t\t\t}\n\n\n\t\t\tif ( objectIndex !== undefined ) {\n\n\t\t\t\tif ( targetObject[ objectIndex ] === undefined ) {\n\n\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\ttargetObject = targetObject[ objectIndex ];\n\n\t\t\t}\n\n\t\t}\n\n\t\t// resolve property\n\t\tconst nodeProperty = targetObject[ propertyName ];\n\n\t\tif ( nodeProperty === undefined ) {\n\n\t\t\tconst nodeName = parsedPath.nodeName;\n\n\t\t\tconsole.error( 'THREE.PropertyBinding: Trying to update property for track: ' + nodeName +\n\t\t\t\t'.' + propertyName + ' but it wasn\\'t found.', targetObject );\n\t\t\treturn;\n\n\t\t}\n\n\t\t// determine versioning scheme\n\t\tlet versioning = this.Versioning.None;\n\n\t\tthis.targetObject = targetObject;\n\n\t\tif ( targetObject.needsUpdate !== undefined ) { // material\n\n\t\t\tversioning = this.Versioning.NeedsUpdate;\n\n\t\t} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform\n\n\t\t\tversioning = this.Versioning.MatrixWorldNeedsUpdate;\n\n\t\t}\n\n\t\t// determine how the property gets bound\n\t\tlet bindingType = this.BindingType.Direct;\n\n\t\tif ( propertyIndex !== undefined ) {\n\n\t\t\t// access a sub element of the property array (only primitives are supported right now)\n\n\t\t\tif ( propertyName === 'morphTargetInfluences' ) {\n\n\t\t\t\t// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.\n\n\t\t\t\t// support resolving morphTarget names into indices.\n\t\t\t\tif ( ! targetObject.geometry ) {\n\n\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! targetObject.geometry.morphAttributes ) {\n\n\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tif ( targetObject.morphTargetDictionary[ propertyIndex ] !== undefined ) {\n\n\t\t\t\t\tpropertyIndex = targetObject.morphTargetDictionary[ propertyIndex ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tbindingType = this.BindingType.ArrayElement;\n\n\t\t\tthis.resolvedProperty = nodeProperty;\n\t\t\tthis.propertyIndex = propertyIndex;\n\n\t\t} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {\n\n\t\t\t// must use copy for Object3D.Euler/Quaternion\n\n\t\t\tbindingType = this.BindingType.HasFromToArray;\n\n\t\t\tthis.resolvedProperty = nodeProperty;\n\n\t\t} else if ( Array.isArray( nodeProperty ) ) {\n\n\t\t\tbindingType = this.BindingType.EntireArray;\n\n\t\t\tthis.resolvedProperty = nodeProperty;\n\n\t\t} else {\n\n\t\t\tthis.propertyName = propertyName;\n\n\t\t}\n\n\t\t// select getter / setter\n\t\tthis.getValue = this.GetterByBindingType[ bindingType ];\n\t\tthis.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];\n\n\t}\n\n\tunbind() {\n\n\t\tthis.node = null;\n\n\t\t// back to the prototype version of getValue / setValue\n\t\t// note: avoiding to mutate the shape of 'this' via 'delete'\n\t\tthis.getValue = this._getValue_unbound;\n\t\tthis.setValue = this._setValue_unbound;\n\n\t}\n\n}\n\nPropertyBinding.Composite = Composite;\n\nPropertyBinding.prototype.BindingType = {\n\tDirect: 0,\n\tEntireArray: 1,\n\tArrayElement: 2,\n\tHasFromToArray: 3\n};\n\nPropertyBinding.prototype.Versioning = {\n\tNone: 0,\n\tNeedsUpdate: 1,\n\tMatrixWorldNeedsUpdate: 2\n};\n\nPropertyBinding.prototype.GetterByBindingType = [\n\n\tPropertyBinding.prototype._getValue_direct,\n\tPropertyBinding.prototype._getValue_array,\n\tPropertyBinding.prototype._getValue_arrayElement,\n\tPropertyBinding.prototype._getValue_toArray,\n\n];\n\nPropertyBinding.prototype.SetterByBindingTypeAndVersioning = [\n\n\t[\n\t\t// Direct\n\t\tPropertyBinding.prototype._setValue_direct,\n\t\tPropertyBinding.prototype._setValue_direct_setNeedsUpdate,\n\t\tPropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate,\n\n\t], [\n\n\t\t// EntireArray\n\n\t\tPropertyBinding.prototype._setValue_array,\n\t\tPropertyBinding.prototype._setValue_array_setNeedsUpdate,\n\t\tPropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate,\n\n\t], [\n\n\t\t// ArrayElement\n\t\tPropertyBinding.prototype._setValue_arrayElement,\n\t\tPropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,\n\t\tPropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,\n\n\t], [\n\n\t\t// HasToFromArray\n\t\tPropertyBinding.prototype._setValue_fromArray,\n\t\tPropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,\n\t\tPropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,\n\n\t]\n\n];\n\n\nexport { PropertyBinding };\n", "const _lut = [ '00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '0a', '0b', '0c', '0d', '0e', '0f', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '1a', '1b', '1c', '1d', '1e', '1f', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '2a', '2b', '2c', '2d', '2e', '2f', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '3a', '3b', '3c', '3d', '3e', '3f', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '4a', '4b', '4c', '4d', '4e', '4f', '50', '51', '52', '53', '54', '55', '56', '57', '58', '59', '5a', '5b', '5c', '5d', '5e', '5f', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '6a', '6b', '6c', '6d', '6e', '6f', '70', '71', '72', '73', '74', '75', '76', '77', '78', '79', '7a', '7b', '7c', '7d', '7e', '7f', '80', '81', '82', '83', '84', '85', '86', '87', '88', '89', '8a', '8b', '8c', '8d', '8e', '8f', '90', '91', '92', '93', '94', '95', '96', '97', '98', '99', '9a', '9b', '9c', '9d', '9e', '9f', 'a0', 'a1', 'a2', 'a3', 'a4', 'a5', 'a6', 'a7', 'a8', 'a9', 'aa', 'ab', 'ac', 'ad', 'ae', 'af', 'b0', 'b1', 'b2', 'b3', 'b4', 'b5', 'b6', 'b7', 'b8', 'b9', 'ba', 'bb', 'bc', 'bd', 'be', 'bf', 'c0', 'c1', 'c2', 'c3', 'c4', 'c5', 'c6', 'c7', 'c8', 'c9', 'ca', 'cb', 'cc', 'cd', 'ce', 'cf', 'd0', 'd1', 'd2', 'd3', 'd4', 'd5', 'd6', 'd7', 'd8', 'd9', 'da', 'db', 'dc', 'dd', 'de', 'df', 'e0', 'e1', 'e2', 'e3', 'e4', 'e5', 'e6', 'e7', 'e8', 'e9', 'ea', 'eb', 'ec', 'ed', 'ee', 'ef', 'f0', 'f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'fa', 'fb', 'fc', 'fd', 'fe', 'ff' ];\n\nlet _seed = 1234567;\n\n\nconst DEG2RAD = Math.PI / 180;\nconst RAD2DEG = 180 / Math.PI;\n\n// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136\nfunction generateUUID() {\n\n\tconst d0 = Math.random() * 0xffffffff | 0;\n\tconst d1 = Math.random() * 0xffffffff | 0;\n\tconst d2 = Math.random() * 0xffffffff | 0;\n\tconst d3 = Math.random() * 0xffffffff | 0;\n\tconst uuid = _lut[ d0 & 0xff ] + _lut[ d0 >> 8 & 0xff ] + _lut[ d0 >> 16 & 0xff ] + _lut[ d0 >> 24 & 0xff ] + '-' +\n\t\t\t_lut[ d1 & 0xff ] + _lut[ d1 >> 8 & 0xff ] + '-' + _lut[ d1 >> 16 & 0x0f | 0x40 ] + _lut[ d1 >> 24 & 0xff ] + '-' +\n\t\t\t_lut[ d2 & 0x3f | 0x80 ] + _lut[ d2 >> 8 & 0xff ] + '-' + _lut[ d2 >> 16 & 0xff ] + _lut[ d2 >> 24 & 0xff ] +\n\t\t\t_lut[ d3 & 0xff ] + _lut[ d3 >> 8 & 0xff ] + _lut[ d3 >> 16 & 0xff ] + _lut[ d3 >> 24 & 0xff ];\n\n\t// .toLowerCase() here flattens concatenated strings to save heap memory space.\n\treturn uuid.toLowerCase();\n\n}\n\nfunction clamp( value, min, max ) {\n\n\treturn Math.max( min, Math.min( max, value ) );\n\n}\n\n// compute euclidean modulo of m % n\n// https://en.wikipedia.org/wiki/Modulo_operation\nfunction euclideanModulo( n, m ) {\n\n\treturn ( ( n % m ) + m ) % m;\n\n}\n\n// Linear mapping from range <a1, a2> to range <b1, b2>\nfunction mapLinear( x, a1, a2, b1, b2 ) {\n\n\treturn b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );\n\n}\n\n// https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/\nfunction inverseLerp( x, y, value ) {\n\n\tif ( x !== y ) {\n\n\t\treturn ( value - x ) / ( y - x );\n\n\t} else {\n\n\t\treturn 0;\n\n\t}\n\n}\n\n// https://en.wikipedia.org/wiki/Linear_interpolation\nfunction lerp( x, y, t ) {\n\n\treturn ( 1 - t ) * x + t * y;\n\n}\n\n// http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/\nfunction damp( x, y, lambda, dt ) {\n\n\treturn lerp( x, y, 1 - Math.exp( - lambda * dt ) );\n\n}\n\n// https://www.desmos.com/calculator/vcsjnyz7x4\nfunction pingpong( x, length = 1 ) {\n\n\treturn length - Math.abs( euclideanModulo( x, length * 2 ) - length );\n\n}\n\n// http://en.wikipedia.org/wiki/Smoothstep\nfunction smoothstep( x, min, max ) {\n\n\tif ( x <= min ) return 0;\n\tif ( x >= max ) return 1;\n\n\tx = ( x - min ) / ( max - min );\n\n\treturn x * x * ( 3 - 2 * x );\n\n}\n\nfunction smootherstep( x, min, max ) {\n\n\tif ( x <= min ) return 0;\n\tif ( x >= max ) return 1;\n\n\tx = ( x - min ) / ( max - min );\n\n\treturn x * x * x * ( x * ( x * 6 - 15 ) + 10 );\n\n}\n\n// Random integer from <low, high> interval\nfunction randInt( low, high ) {\n\n\treturn low + Math.floor( Math.random() * ( high - low + 1 ) );\n\n}\n\n// Random float from <low, high> interval\nfunction randFloat( low, high ) {\n\n\treturn low + Math.random() * ( high - low );\n\n}\n\n// Random float from <-range/2, range/2> interval\nfunction randFloatSpread( range ) {\n\n\treturn range * ( 0.5 - Math.random() );\n\n}\n\n// Deterministic pseudo-random float in the interval [ 0, 1 ]\nfunction seededRandom( s ) {\n\n\tif ( s !== undefined ) _seed = s;\n\n\t// Mulberry32 generator\n\n\tlet t = _seed += 0x6D2B79F5;\n\n\tt = Math.imul( t ^ t >>> 15, t | 1 );\n\n\tt ^= t + Math.imul( t ^ t >>> 7, t | 61 );\n\n\treturn ( ( t ^ t >>> 14 ) >>> 0 ) / 4294967296;\n\n}\n\nfunction degToRad( degrees ) {\n\n\treturn degrees * DEG2RAD;\n\n}\n\nfunction radToDeg( radians ) {\n\n\treturn radians * RAD2DEG;\n\n}\n\nfunction isPowerOfTwo( value ) {\n\n\treturn ( value & ( value - 1 ) ) === 0 && value !== 0;\n\n}\n\nfunction ceilPowerOfTwo( value ) {\n\n\treturn Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );\n\n}\n\nfunction floorPowerOfTwo( value ) {\n\n\treturn Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );\n\n}\n\nfunction setQuaternionFromProperEuler( q, a, b, c, order ) {\n\n\t// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles\n\n\t// rotations are applied to the axes in the order specified by 'order'\n\t// rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'\n\t// angles are in radians\n\n\tconst cos = Math.cos;\n\tconst sin = Math.sin;\n\n\tconst c2 = cos( b / 2 );\n\tconst s2 = sin( b / 2 );\n\n\tconst c13 = cos( ( a + c ) / 2 );\n\tconst s13 = sin( ( a + c ) / 2 );\n\n\tconst c1_3 = cos( ( a - c ) / 2 );\n\tconst s1_3 = sin( ( a - c ) / 2 );\n\n\tconst c3_1 = cos( ( c - a ) / 2 );\n\tconst s3_1 = sin( ( c - a ) / 2 );\n\n\tswitch ( order ) {\n\n\t\tcase 'XYX':\n\t\t\tq.set( c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'YZY':\n\t\t\tq.set( s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'ZXZ':\n\t\t\tq.set( s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'XZX':\n\t\t\tq.set( c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'YXY':\n\t\t\tq.set( s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'ZYZ':\n\t\t\tq.set( s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13 );\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tconsole.warn( 'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order );\n\n\t}\n\n}\n\nfunction denormalize( value, array ) {\n\n\tswitch ( array.constructor ) {\n\n\t\tcase Float32Array:\n\n\t\t\treturn value;\n\n\t\tcase Uint32Array:\n\n\t\t\treturn value / 4294967295.0;\n\n\t\tcase Uint16Array:\n\n\t\t\treturn value / 65535.0;\n\n\t\tcase Uint8Array:\n\n\t\t\treturn value / 255.0;\n\n\t\tcase Int32Array:\n\n\t\t\treturn Math.max( value / 2147483647.0, - 1.0 );\n\n\t\tcase Int16Array:\n\n\t\t\treturn Math.max( value / 32767.0, - 1.0 );\n\n\t\tcase Int8Array:\n\n\t\t\treturn Math.max( value / 127.0, - 1.0 );\n\n\t\tdefault:\n\n\t\t\tthrow new Error( 'Invalid component type.' );\n\n\t}\n\n}\n\nfunction normalize( value, array ) {\n\n\tswitch ( array.constructor ) {\n\n\t\tcase Float32Array:\n\n\t\t\treturn value;\n\n\t\tcase Uint32Array:\n\n\t\t\treturn Math.round( value * 4294967295.0 );\n\n\t\tcase Uint16Array:\n\n\t\t\treturn Math.round( value * 65535.0 );\n\n\t\tcase Uint8Array:\n\n\t\t\treturn Math.round( value * 255.0 );\n\n\t\tcase Int32Array:\n\n\t\t\treturn Math.round( value * 2147483647.0 );\n\n\t\tcase Int16Array:\n\n\t\t\treturn Math.round( value * 32767.0 );\n\n\t\tcase Int8Array:\n\n\t\t\treturn Math.round( value * 127.0 );\n\n\t\tdefault:\n\n\t\t\tthrow new Error( 'Invalid component type.' );\n\n\t}\n\n}\n\nconst MathUtils = {\n\tDEG2RAD: DEG2RAD,\n\tRAD2DEG: RAD2DEG,\n\tgenerateUUID: generateUUID,\n\tclamp: clamp,\n\teuclideanModulo: euclideanModulo,\n\tmapLinear: mapLinear,\n\tinverseLerp: inverseLerp,\n\tlerp: lerp,\n\tdamp: damp,\n\tpingpong: pingpong,\n\tsmoothstep: smoothstep,\n\tsmootherstep: smootherstep,\n\trandInt: randInt,\n\trandFloat: randFloat,\n\trandFloatSpread: randFloatSpread,\n\tseededRandom: seededRandom,\n\tdegToRad: degToRad,\n\tradToDeg: radToDeg,\n\tisPowerOfTwo: isPowerOfTwo,\n\tceilPowerOfTwo: ceilPowerOfTwo,\n\tfloorPowerOfTwo: floorPowerOfTwo,\n\tsetQuaternionFromProperEuler: setQuaternionFromProperEuler,\n\tnormalize: normalize,\n\tdenormalize: denormalize\n};\n\nexport {\n\tDEG2RAD,\n\tRAD2DEG,\n\tgenerateUUID,\n\tclamp,\n\teuclideanModulo,\n\tmapLinear,\n\tinverseLerp,\n\tlerp,\n\tdamp,\n\tpingpong,\n\tsmoothstep,\n\tsmootherstep,\n\trandInt,\n\trandFloat,\n\trandFloatSpread,\n\tseededRandom,\n\tdegToRad,\n\tradToDeg,\n\tisPowerOfTwo,\n\tceilPowerOfTwo,\n\tfloorPowerOfTwo,\n\tsetQuaternionFromProperEuler,\n\tnormalize,\n\tdenormalize,\n\tMathUtils\n};\n", "import * as MathUtils from './MathUtils.js';\n\nclass Quaternion {\n\n\tconstructor( x = 0, y = 0, z = 0, w = 1 ) {\n\n\t\tthis.isQuaternion = true;\n\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._z = z;\n\t\tthis._w = w;\n\n\t}\n\n\tstatic slerpFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {\n\n\t\t// fuzz-free, array-based Quaternion SLERP operation\n\n\t\tlet x0 = src0[ srcOffset0 + 0 ],\n\t\t\ty0 = src0[ srcOffset0 + 1 ],\n\t\t\tz0 = src0[ srcOffset0 + 2 ],\n\t\t\tw0 = src0[ srcOffset0 + 3 ];\n\n\t\tconst x1 = src1[ srcOffset1 + 0 ],\n\t\t\ty1 = src1[ srcOffset1 + 1 ],\n\t\t\tz1 = src1[ srcOffset1 + 2 ],\n\t\t\tw1 = src1[ srcOffset1 + 3 ];\n\n\t\tif ( t === 0 ) {\n\n\t\t\tdst[ dstOffset + 0 ] = x0;\n\t\t\tdst[ dstOffset + 1 ] = y0;\n\t\t\tdst[ dstOffset + 2 ] = z0;\n\t\t\tdst[ dstOffset + 3 ] = w0;\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( t === 1 ) {\n\n\t\t\tdst[ dstOffset + 0 ] = x1;\n\t\t\tdst[ dstOffset + 1 ] = y1;\n\t\t\tdst[ dstOffset + 2 ] = z1;\n\t\t\tdst[ dstOffset + 3 ] = w1;\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {\n\n\t\t\tlet s = 1 - t;\n\t\t\tconst cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,\n\t\t\t\tdir = ( cos >= 0 ? 1 : - 1 ),\n\t\t\t\tsqrSin = 1 - cos * cos;\n\n\t\t\t// Skip the Slerp for tiny steps to avoid numeric problems:\n\t\t\tif ( sqrSin > Number.EPSILON ) {\n\n\t\t\t\tconst sin = Math.sqrt( sqrSin ),\n\t\t\t\t\tlen = Math.atan2( sin, cos * dir );\n\n\t\t\t\ts = Math.sin( s * len ) / sin;\n\t\t\t\tt = Math.sin( t * len ) / sin;\n\n\t\t\t}\n\n\t\t\tconst tDir = t * dir;\n\n\t\t\tx0 = x0 * s + x1 * tDir;\n\t\t\ty0 = y0 * s + y1 * tDir;\n\t\t\tz0 = z0 * s + z1 * tDir;\n\t\t\tw0 = w0 * s + w1 * tDir;\n\n\t\t\t// Normalize in case we just did a lerp:\n\t\t\tif ( s === 1 - t ) {\n\n\t\t\t\tconst f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );\n\n\t\t\t\tx0 *= f;\n\t\t\t\ty0 *= f;\n\t\t\t\tz0 *= f;\n\t\t\t\tw0 *= f;\n\n\t\t\t}\n\n\t\t}\n\n\t\tdst[ dstOffset ] = x0;\n\t\tdst[ dstOffset + 1 ] = y0;\n\t\tdst[ dstOffset + 2 ] = z0;\n\t\tdst[ dstOffset + 3 ] = w0;\n\n\t}\n\n\tstatic multiplyQuaternionsFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1 ) {\n\n\t\tconst x0 = src0[ srcOffset0 ];\n\t\tconst y0 = src0[ srcOffset0 + 1 ];\n\t\tconst z0 = src0[ srcOffset0 + 2 ];\n\t\tconst w0 = src0[ srcOffset0 + 3 ];\n\n\t\tconst x1 = src1[ srcOffset1 ];\n\t\tconst y1 = src1[ srcOffset1 + 1 ];\n\t\tconst z1 = src1[ srcOffset1 + 2 ];\n\t\tconst w1 = src1[ srcOffset1 + 3 ];\n\n\t\tdst[ dstOffset ] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;\n\t\tdst[ dstOffset + 1 ] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;\n\t\tdst[ dstOffset + 2 ] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;\n\t\tdst[ dstOffset + 3 ] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;\n\n\t\treturn dst;\n\n\t}\n\n\tget x() {\n\n\t\treturn this._x;\n\n\t}\n\n\tset x( value ) {\n\n\t\tthis._x = value;\n\t\tthis._onChangeCallback();\n\n\t}\n\n\tget y() {\n\n\t\treturn this._y;\n\n\t}\n\n\tset y( value ) {\n\n\t\tthis._y = value;\n\t\tthis._onChangeCallback();\n\n\t}\n\n\tget z() {\n\n\t\treturn this._z;\n\n\t}\n\n\tset z( value ) {\n\n\t\tthis._z = value;\n\t\tthis._onChangeCallback();\n\n\t}\n\n\tget w() {\n\n\t\treturn this._w;\n\n\t}\n\n\tset w( value ) {\n\n\t\tthis._w = value;\n\t\tthis._onChangeCallback();\n\n\t}\n\n\tset( x, y, z, w ) {\n\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._z = z;\n\t\tthis._w = w;\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this._x, this._y, this._z, this._w );\n\n\t}\n\n\tcopy( quaternion ) {\n\n\t\tthis._x = quaternion.x;\n\t\tthis._y = quaternion.y;\n\t\tthis._z = quaternion.z;\n\t\tthis._w = quaternion.w;\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tsetFromEuler( euler, update = true ) {\n\n\t\tconst x = euler._x, y = euler._y, z = euler._z, order = euler._order;\n\n\t\t// http://www.mathworks.com/matlabcentral/fileexchange/\n\t\t// \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\n\t\t//\tcontent/SpinCalc.m\n\n\t\tconst cos = Math.cos;\n\t\tconst sin = Math.sin;\n\n\t\tconst c1 = cos( x / 2 );\n\t\tconst c2 = cos( y / 2 );\n\t\tconst c3 = cos( z / 2 );\n\n\t\tconst s1 = sin( x / 2 );\n\t\tconst s2 = sin( y / 2 );\n\t\tconst s3 = sin( z / 2 );\n\n\t\tswitch ( order ) {\n\n\t\t\tcase 'XYZ':\n\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\t\t\t\tbreak;\n\n\t\t\tcase 'YXZ':\n\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\t\t\t\tbreak;\n\n\t\t\tcase 'ZXY':\n\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\t\t\t\tbreak;\n\n\t\t\tcase 'ZYX':\n\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\t\t\t\tbreak;\n\n\t\t\tcase 'YZX':\n\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\t\t\t\tbreak;\n\n\t\t\tcase 'XZY':\n\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tconsole.warn( 'THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order );\n\n\t\t}\n\n\t\tif ( update === true ) this._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tsetFromAxisAngle( axis, angle ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\n\n\t\t// assumes axis is normalized\n\n\t\tconst halfAngle = angle / 2, s = Math.sin( halfAngle );\n\n\t\tthis._x = axis.x * s;\n\t\tthis._y = axis.y * s;\n\t\tthis._z = axis.z * s;\n\t\tthis._w = Math.cos( halfAngle );\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tsetFromRotationMatrix( m ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\tconst te = m.elements,\n\n\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\n\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\n\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],\n\n\t\t\ttrace = m11 + m22 + m33;\n\n\t\tif ( trace > 0 ) {\n\n\t\t\tconst s = 0.5 / Math.sqrt( trace + 1.0 );\n\n\t\t\tthis._w = 0.25 / s;\n\t\t\tthis._x = ( m32 - m23 ) * s;\n\t\t\tthis._y = ( m13 - m31 ) * s;\n\t\t\tthis._z = ( m21 - m12 ) * s;\n\n\t\t} else if ( m11 > m22 && m11 > m33 ) {\n\n\t\t\tconst s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );\n\n\t\t\tthis._w = ( m32 - m23 ) / s;\n\t\t\tthis._x = 0.25 * s;\n\t\t\tthis._y = ( m12 + m21 ) / s;\n\t\t\tthis._z = ( m13 + m31 ) / s;\n\n\t\t} else if ( m22 > m33 ) {\n\n\t\t\tconst s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );\n\n\t\t\tthis._w = ( m13 - m31 ) / s;\n\t\t\tthis._x = ( m12 + m21 ) / s;\n\t\t\tthis._y = 0.25 * s;\n\t\t\tthis._z = ( m23 + m32 ) / s;\n\n\t\t} else {\n\n\t\t\tconst s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );\n\n\t\t\tthis._w = ( m21 - m12 ) / s;\n\t\t\tthis._x = ( m13 + m31 ) / s;\n\t\t\tthis._y = ( m23 + m32 ) / s;\n\t\t\tthis._z = 0.25 * s;\n\n\t\t}\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tsetFromUnitVectors( vFrom, vTo ) {\n\n\t\t// assumes direction vectors vFrom and vTo are normalized\n\n\t\tlet r = vFrom.dot( vTo ) + 1;\n\n\t\tif ( r < Number.EPSILON ) {\n\n\t\t\t// vFrom and vTo point in opposite directions\n\n\t\t\tr = 0;\n\n\t\t\tif ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {\n\n\t\t\t\tthis._x = - vFrom.y;\n\t\t\t\tthis._y = vFrom.x;\n\t\t\t\tthis._z = 0;\n\t\t\t\tthis._w = r;\n\n\t\t\t} else {\n\n\t\t\t\tthis._x = 0;\n\t\t\t\tthis._y = - vFrom.z;\n\t\t\t\tthis._z = vFrom.y;\n\t\t\t\tthis._w = r;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3\n\n\t\t\tthis._x = vFrom.y * vTo.z - vFrom.z * vTo.y;\n\t\t\tthis._y = vFrom.z * vTo.x - vFrom.x * vTo.z;\n\t\t\tthis._z = vFrom.x * vTo.y - vFrom.y * vTo.x;\n\t\t\tthis._w = r;\n\n\t\t}\n\n\t\treturn this.normalize();\n\n\t}\n\n\tangleTo( q ) {\n\n\t\treturn 2 * Math.acos( Math.abs( MathUtils.clamp( this.dot( q ), - 1, 1 ) ) );\n\n\t}\n\n\trotateTowards( q, step ) {\n\n\t\tconst angle = this.angleTo( q );\n\n\t\tif ( angle === 0 ) return this;\n\n\t\tconst t = Math.min( 1, step / angle );\n\n\t\tthis.slerp( q, t );\n\n\t\treturn this;\n\n\t}\n\n\tidentity() {\n\n\t\treturn this.set( 0, 0, 0, 1 );\n\n\t}\n\n\tinvert() {\n\n\t\t// quaternion is assumed to have unit length\n\n\t\treturn this.conjugate();\n\n\t}\n\n\tconjugate() {\n\n\t\tthis._x *= - 1;\n\t\tthis._y *= - 1;\n\t\tthis._z *= - 1;\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tdot( v ) {\n\n\t\treturn this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\n\n\t}\n\n\tlengthSq() {\n\n\t\treturn this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\n\n\t}\n\n\tlength() {\n\n\t\treturn Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );\n\n\t}\n\n\tnormalize() {\n\n\t\tlet l = this.length();\n\n\t\tif ( l === 0 ) {\n\n\t\t\tthis._x = 0;\n\t\t\tthis._y = 0;\n\t\t\tthis._z = 0;\n\t\t\tthis._w = 1;\n\n\t\t} else {\n\n\t\t\tl = 1 / l;\n\n\t\t\tthis._x = this._x * l;\n\t\t\tthis._y = this._y * l;\n\t\t\tthis._z = this._z * l;\n\t\t\tthis._w = this._w * l;\n\n\t\t}\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tmultiply( q ) {\n\n\t\treturn this.multiplyQuaternions( this, q );\n\n\t}\n\n\tpremultiply( q ) {\n\n\t\treturn this.multiplyQuaternions( q, this );\n\n\t}\n\n\tmultiplyQuaternions( a, b ) {\n\n\t\t// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\n\n\t\tconst qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;\n\t\tconst qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;\n\n\t\tthis._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\n\t\tthis._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\n\t\tthis._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\n\t\tthis._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tslerp( qb, t ) {\n\n\t\tif ( t === 0 ) return this;\n\t\tif ( t === 1 ) return this.copy( qb );\n\n\t\tconst x = this._x, y = this._y, z = this._z, w = this._w;\n\n\t\t// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\n\n\t\tlet cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;\n\n\t\tif ( cosHalfTheta < 0 ) {\n\n\t\t\tthis._w = - qb._w;\n\t\t\tthis._x = - qb._x;\n\t\t\tthis._y = - qb._y;\n\t\t\tthis._z = - qb._z;\n\n\t\t\tcosHalfTheta = - cosHalfTheta;\n\n\t\t} else {\n\n\t\t\tthis.copy( qb );\n\n\t\t}\n\n\t\tif ( cosHalfTheta >= 1.0 ) {\n\n\t\t\tthis._w = w;\n\t\t\tthis._x = x;\n\t\t\tthis._y = y;\n\t\t\tthis._z = z;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tconst sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;\n\n\t\tif ( sqrSinHalfTheta <= Number.EPSILON ) {\n\n\t\t\tconst s = 1 - t;\n\t\t\tthis._w = s * w + t * this._w;\n\t\t\tthis._x = s * x + t * this._x;\n\t\t\tthis._y = s * y + t * this._y;\n\t\t\tthis._z = s * z + t * this._z;\n\n\t\t\tthis.normalize(); // normalize calls _onChangeCallback()\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tconst sinHalfTheta = Math.sqrt( sqrSinHalfTheta );\n\t\tconst halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );\n\t\tconst ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,\n\t\t\tratioB = Math.sin( t * halfTheta ) / sinHalfTheta;\n\n\t\tthis._w = ( w * ratioA + this._w * ratioB );\n\t\tthis._x = ( x * ratioA + this._x * ratioB );\n\t\tthis._y = ( y * ratioA + this._y * ratioB );\n\t\tthis._z = ( z * ratioA + this._z * ratioB );\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tslerpQuaternions( qa, qb, t ) {\n\n\t\treturn this.copy( qa ).slerp( qb, t );\n\n\t}\n\n\trandom() {\n\n\t\t// sets this quaternion to a uniform random unit quaternnion\n\n\t\t// Ken Shoemake\n\t\t// Uniform random rotations\n\t\t// D. Kirk, editor, Graphics Gems III, pages 124-132. Academic Press, New York, 1992.\n\n\t\tconst theta1 = 2 * Math.PI * Math.random();\n\t\tconst theta2 = 2 * Math.PI * Math.random();\n\n\t\tconst x0 = Math.random();\n\t\tconst r1 = Math.sqrt( 1 - x0 );\n\t\tconst r2 = Math.sqrt( x0 );\n\n\t\treturn this.set(\n\t\t\tr1 * Math.sin( theta1 ),\n\t\t\tr1 * Math.cos( theta1 ),\n\t\t\tr2 * Math.sin( theta2 ),\n\t\t\tr2 * Math.cos( theta2 ),\n\t\t);\n\n\t}\n\n\tequals( quaternion ) {\n\n\t\treturn ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );\n\n\t}\n\n\tfromArray( array, offset = 0 ) {\n\n\t\tthis._x = array[ offset ];\n\t\tthis._y = array[ offset + 1 ];\n\t\tthis._z = array[ offset + 2 ];\n\t\tthis._w = array[ offset + 3 ];\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tarray[ offset ] = this._x;\n\t\tarray[ offset + 1 ] = this._y;\n\t\tarray[ offset + 2 ] = this._z;\n\t\tarray[ offset + 3 ] = this._w;\n\n\t\treturn array;\n\n\t}\n\n\tfromBufferAttribute( attribute, index ) {\n\n\t\tthis._x = attribute.getX( index );\n\t\tthis._y = attribute.getY( index );\n\t\tthis._z = attribute.getZ( index );\n\t\tthis._w = attribute.getW( index );\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\treturn this.toArray();\n\n\t}\n\n\t_onChange( callback ) {\n\n\t\tthis._onChangeCallback = callback;\n\n\t\treturn this;\n\n\t}\n\n\t_onChangeCallback() {}\n\n\t*[ Symbol.iterator ]() {\n\n\t\tyield this._x;\n\t\tyield this._y;\n\t\tyield this._z;\n\t\tyield this._w;\n\n\t}\n\n}\n\nexport { Quaternion };\n", "import { Quaternion } from '../math/Quaternion.js';\n\nclass PropertyMixer {\n\n\tconstructor( binding, typeName, valueSize ) {\n\n\t\tthis.binding = binding;\n\t\tthis.valueSize = valueSize;\n\n\t\tlet mixFunction,\n\t\t\tmixFunctionAdditive,\n\t\t\tsetIdentity;\n\n\t\t// buffer layout: [ incoming | accu0 | accu1 | orig | addAccu | (optional work) ]\n\t\t//\n\t\t// interpolators can use .buffer as their .result\n\t\t// the data then goes to 'incoming'\n\t\t//\n\t\t// 'accu0' and 'accu1' are used frame-interleaved for\n\t\t// the cumulative result and are compared to detect\n\t\t// changes\n\t\t//\n\t\t// 'orig' stores the original state of the property\n\t\t//\n\t\t// 'add' is used for additive cumulative results\n\t\t//\n\t\t// 'work' is optional and is only present for quaternion types. It is used\n\t\t// to store intermediate quaternion multiplication results\n\n\t\tswitch ( typeName ) {\n\n\t\t\tcase 'quaternion':\n\t\t\t\tmixFunction = this._slerp;\n\t\t\t\tmixFunctionAdditive = this._slerpAdditive;\n\t\t\t\tsetIdentity = this._setAdditiveIdentityQuaternion;\n\n\t\t\t\tthis.buffer = new Float64Array( valueSize * 6 );\n\t\t\t\tthis._workIndex = 5;\n\t\t\t\tbreak;\n\n\t\t\tcase 'string':\n\t\t\tcase 'bool':\n\t\t\t\tmixFunction = this._select;\n\n\t\t\t\t// Use the regular mix function and for additive on these types,\n\t\t\t\t// additive is not relevant for non-numeric types\n\t\t\t\tmixFunctionAdditive = this._select;\n\n\t\t\t\tsetIdentity = this._setAdditiveIdentityOther;\n\n\t\t\t\tthis.buffer = new Array( valueSize * 5 );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tmixFunction = this._lerp;\n\t\t\t\tmixFunctionAdditive = this._lerpAdditive;\n\t\t\t\tsetIdentity = this._setAdditiveIdentityNumeric;\n\n\t\t\t\tthis.buffer = new Float64Array( valueSize * 5 );\n\n\t\t}\n\n\t\tthis._mixBufferRegion = mixFunction;\n\t\tthis._mixBufferRegionAdditive = mixFunctionAdditive;\n\t\tthis._setIdentity = setIdentity;\n\t\tthis._origIndex = 3;\n\t\tthis._addIndex = 4;\n\n\t\tthis.cumulativeWeight = 0;\n\t\tthis.cumulativeWeightAdditive = 0;\n\n\t\tthis.useCount = 0;\n\t\tthis.referenceCount = 0;\n\n\t}\n\n\t// accumulate data in the 'incoming' region into 'accu<i>'\n\taccumulate( accuIndex, weight ) {\n\n\t\t// note: happily accumulating nothing when weight = 0, the caller knows\n\t\t// the weight and shouldn't have made the call in the first place\n\n\t\tconst buffer = this.buffer,\n\t\t\tstride = this.valueSize,\n\t\t\toffset = accuIndex * stride + stride;\n\n\t\tlet currentWeight = this.cumulativeWeight;\n\n\t\tif ( currentWeight === 0 ) {\n\n\t\t\t// accuN := incoming * weight\n\n\t\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\t\tbuffer[ offset + i ] = buffer[ i ];\n\n\t\t\t}\n\n\t\t\tcurrentWeight = weight;\n\n\t\t} else {\n\n\t\t\t// accuN := accuN + incoming * weight\n\n\t\t\tcurrentWeight += weight;\n\t\t\tconst mix = weight / currentWeight;\n\t\t\tthis._mixBufferRegion( buffer, offset, 0, mix, stride );\n\n\t\t}\n\n\t\tthis.cumulativeWeight = currentWeight;\n\n\t}\n\n\t// accumulate data in the 'incoming' region into 'add'\n\taccumulateAdditive( weight ) {\n\n\t\tconst buffer = this.buffer,\n\t\t\tstride = this.valueSize,\n\t\t\toffset = stride * this._addIndex;\n\n\t\tif ( this.cumulativeWeightAdditive === 0 ) {\n\n\t\t\t// add = identity\n\n\t\t\tthis._setIdentity();\n\n\t\t}\n\n\t\t// add := add + incoming * weight\n\n\t\tthis._mixBufferRegionAdditive( buffer, offset, 0, weight, stride );\n\t\tthis.cumulativeWeightAdditive += weight;\n\n\t}\n\n\t// apply the state of 'accu<i>' to the binding when accus differ\n\tapply( accuIndex ) {\n\n\t\tconst stride = this.valueSize,\n\t\t\tbuffer = this.buffer,\n\t\t\toffset = accuIndex * stride + stride,\n\n\t\t\tweight = this.cumulativeWeight,\n\t\t\tweightAdditive = this.cumulativeWeightAdditive,\n\n\t\t\tbinding = this.binding;\n\n\t\tthis.cumulativeWeight = 0;\n\t\tthis.cumulativeWeightAdditive = 0;\n\n\t\tif ( weight < 1 ) {\n\n\t\t\t// accuN := accuN + original * ( 1 - cumulativeWeight )\n\n\t\t\tconst originalValueOffset = stride * this._origIndex;\n\n\t\t\tthis._mixBufferRegion(\n\t\t\t\tbuffer, offset, originalValueOffset, 1 - weight, stride );\n\n\t\t}\n\n\t\tif ( weightAdditive > 0 ) {\n\n\t\t\t// accuN := accuN + additive accuN\n\n\t\t\tthis._mixBufferRegionAdditive( buffer, offset, this._addIndex * stride, 1, stride );\n\n\t\t}\n\n\t\tfor ( let i = stride, e = stride + stride; i !== e; ++ i ) {\n\n\t\t\tif ( buffer[ i ] !== buffer[ i + stride ] ) {\n\n\t\t\t\t// value has changed -> update scene graph\n\n\t\t\t\tbinding.setValue( buffer, offset );\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// remember the state of the bound property and copy it to both accus\n\tsaveOriginalState() {\n\n\t\tconst binding = this.binding;\n\n\t\tconst buffer = this.buffer,\n\t\t\tstride = this.valueSize,\n\n\t\t\toriginalValueOffset = stride * this._origIndex;\n\n\t\tbinding.getValue( buffer, originalValueOffset );\n\n\t\t// accu[0..1] := orig -- initially detect changes against the original\n\t\tfor ( let i = stride, e = originalValueOffset; i !== e; ++ i ) {\n\n\t\t\tbuffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];\n\n\t\t}\n\n\t\t// Add to identity for additive\n\t\tthis._setIdentity();\n\n\t\tthis.cumulativeWeight = 0;\n\t\tthis.cumulativeWeightAdditive = 0;\n\n\t}\n\n\t// apply the state previously taken via 'saveOriginalState' to the binding\n\trestoreOriginalState() {\n\n\t\tconst originalValueOffset = this.valueSize * 3;\n\t\tthis.binding.setValue( this.buffer, originalValueOffset );\n\n\t}\n\n\t_setAdditiveIdentityNumeric() {\n\n\t\tconst startIndex = this._addIndex * this.valueSize;\n\t\tconst endIndex = startIndex + this.valueSize;\n\n\t\tfor ( let i = startIndex; i < endIndex; i ++ ) {\n\n\t\t\tthis.buffer[ i ] = 0;\n\n\t\t}\n\n\t}\n\n\t_setAdditiveIdentityQuaternion() {\n\n\t\tthis._setAdditiveIdentityNumeric();\n\t\tthis.buffer[ this._addIndex * this.valueSize + 3 ] = 1;\n\n\t}\n\n\t_setAdditiveIdentityOther() {\n\n\t\tconst startIndex = this._origIndex * this.valueSize;\n\t\tconst targetIndex = this._addIndex * this.valueSize;\n\n\t\tfor ( let i = 0; i < this.valueSize; i ++ ) {\n\n\t\t\tthis.buffer[ targetIndex + i ] = this.buffer[ startIndex + i ];\n\n\t\t}\n\n\t}\n\n\n\t// mix functions\n\n\t_select( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\tif ( t >= 0.5 ) {\n\n\t\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\t\tbuffer[ dstOffset + i ] = buffer[ srcOffset + i ];\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_slerp( buffer, dstOffset, srcOffset, t ) {\n\n\t\tQuaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t );\n\n\t}\n\n\t_slerpAdditive( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\tconst workOffset = this._workIndex * stride;\n\n\t\t// Store result in intermediate buffer offset\n\t\tQuaternion.multiplyQuaternionsFlat( buffer, workOffset, buffer, dstOffset, buffer, srcOffset );\n\n\t\t// Slerp to the intermediate result\n\t\tQuaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t );\n\n\t}\n\n\t_lerp( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\tconst s = 1 - t;\n\n\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\tconst j = dstOffset + i;\n\n\t\t\tbuffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;\n\n\t\t}\n\n\t}\n\n\t_lerpAdditive( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\tconst j = dstOffset + i;\n\n\t\t\tbuffer[ j ] = buffer[ j ] + buffer[ srcOffset + i ] * t;\n\n\t\t}\n\n\t}\n\n}\n\n\nexport { PropertyMixer };\n", "import { Quaternion } from '../math/Quaternion.js';\nimport { AdditiveAnimationBlendMode } from '../constants.js';\n\n// converts an array to a specific type\nfunction convertArray( array, type, forceClone ) {\n\n\tif ( ! array || // let 'undefined' and 'null' pass\n\t\t! forceClone && array.constructor === type ) return array;\n\n\tif ( typeof type.BYTES_PER_ELEMENT === 'number' ) {\n\n\t\treturn new type( array ); // create typed array\n\n\t}\n\n\treturn Array.prototype.slice.call( array ); // create Array\n\n}\n\nfunction isTypedArray( object ) {\n\n\treturn ArrayBuffer.isView( object ) &&\n\t\t! ( object instanceof DataView );\n\n}\n\n// returns an array by which times and values can be sorted\nfunction getKeyframeOrder( times ) {\n\n\tfunction compareTime( i, j ) {\n\n\t\treturn times[ i ] - times[ j ];\n\n\t}\n\n\tconst n = times.length;\n\tconst result = new Array( n );\n\tfor ( let i = 0; i !== n; ++ i ) result[ i ] = i;\n\n\tresult.sort( compareTime );\n\n\treturn result;\n\n}\n\n// uses the array previously returned by 'getKeyframeOrder' to sort data\nfunction sortedArray( values, stride, order ) {\n\n\tconst nValues = values.length;\n\tconst result = new values.constructor( nValues );\n\n\tfor ( let i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {\n\n\t\tconst srcOffset = order[ i ] * stride;\n\n\t\tfor ( let j = 0; j !== stride; ++ j ) {\n\n\t\t\tresult[ dstOffset ++ ] = values[ srcOffset + j ];\n\n\t\t}\n\n\t}\n\n\treturn result;\n\n}\n\n// function for parsing AOS keyframe formats\nfunction flattenJSON( jsonKeys, times, values, valuePropertyName ) {\n\n\tlet i = 1, key = jsonKeys[ 0 ];\n\n\twhile ( key !== undefined && key[ valuePropertyName ] === undefined ) {\n\n\t\tkey = jsonKeys[ i ++ ];\n\n\t}\n\n\tif ( key === undefined ) return; // no data\n\n\tlet value = key[ valuePropertyName ];\n\tif ( value === undefined ) return; // no data\n\n\tif ( Array.isArray( value ) ) {\n\n\t\tdo {\n\n\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\tif ( value !== undefined ) {\n\n\t\t\t\ttimes.push( key.time );\n\t\t\t\tvalues.push.apply( values, value ); // push all elements\n\n\t\t\t}\n\n\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t} while ( key !== undefined );\n\n\t} else if ( value.toArray !== undefined ) {\n\n\t\t// ...assume THREE.Math-ish\n\n\t\tdo {\n\n\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\tif ( value !== undefined ) {\n\n\t\t\t\ttimes.push( key.time );\n\t\t\t\tvalue.toArray( values, values.length );\n\n\t\t\t}\n\n\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t} while ( key !== undefined );\n\n\t} else {\n\n\t\t// otherwise push as-is\n\n\t\tdo {\n\n\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\tif ( value !== undefined ) {\n\n\t\t\t\ttimes.push( key.time );\n\t\t\t\tvalues.push( value );\n\n\t\t\t}\n\n\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t} while ( key !== undefined );\n\n\t}\n\n}\n\nfunction subclip( sourceClip, name, startFrame, endFrame, fps = 30 ) {\n\n\tconst clip = sourceClip.clone();\n\n\tclip.name = name;\n\n\tconst tracks = [];\n\n\tfor ( let i = 0; i < clip.tracks.length; ++ i ) {\n\n\t\tconst track = clip.tracks[ i ];\n\t\tconst valueSize = track.getValueSize();\n\n\t\tconst times = [];\n\t\tconst values = [];\n\n\t\tfor ( let j = 0; j < track.times.length; ++ j ) {\n\n\t\t\tconst frame = track.times[ j ] * fps;\n\n\t\t\tif ( frame < startFrame || frame >= endFrame ) continue;\n\n\t\t\ttimes.push( track.times[ j ] );\n\n\t\t\tfor ( let k = 0; k < valueSize; ++ k ) {\n\n\t\t\t\tvalues.push( track.values[ j * valueSize + k ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( times.length === 0 ) continue;\n\n\t\ttrack.times = convertArray( times, track.times.constructor );\n\t\ttrack.values = convertArray( values, track.values.constructor );\n\n\t\ttracks.push( track );\n\n\t}\n\n\tclip.tracks = tracks;\n\n\t// find minimum .times value across all tracks in the trimmed clip\n\n\tlet minStartTime = Infinity;\n\n\tfor ( let i = 0; i < clip.tracks.length; ++ i ) {\n\n\t\tif ( minStartTime > clip.tracks[ i ].times[ 0 ] ) {\n\n\t\t\tminStartTime = clip.tracks[ i ].times[ 0 ];\n\n\t\t}\n\n\t}\n\n\t// shift all tracks such that clip begins at t=0\n\n\tfor ( let i = 0; i < clip.tracks.length; ++ i ) {\n\n\t\tclip.tracks[ i ].shift( - 1 * minStartTime );\n\n\t}\n\n\tclip.resetDuration();\n\n\treturn clip;\n\n}\n\nfunction makeClipAdditive( targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30 ) {\n\n\tif ( fps <= 0 ) fps = 30;\n\n\tconst numTracks = referenceClip.tracks.length;\n\tconst referenceTime = referenceFrame / fps;\n\n\t// Make each track's values relative to the values at the reference frame\n\tfor ( let i = 0; i < numTracks; ++ i ) {\n\n\t\tconst referenceTrack = referenceClip.tracks[ i ];\n\t\tconst referenceTrackType = referenceTrack.ValueTypeName;\n\n\t\t// Skip this track if it's non-numeric\n\t\tif ( referenceTrackType === 'bool' || referenceTrackType === 'string' ) continue;\n\n\t\t// Find the track in the target clip whose name and type matches the reference track\n\t\tconst targetTrack = targetClip.tracks.find( function ( track ) {\n\n\t\t\treturn track.name === referenceTrack.name\n\t\t\t\t&& track.ValueTypeName === referenceTrackType;\n\n\t\t} );\n\n\t\tif ( targetTrack === undefined ) continue;\n\n\t\tlet referenceOffset = 0;\n\t\tconst referenceValueSize = referenceTrack.getValueSize();\n\n\t\tif ( referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {\n\n\t\t\treferenceOffset = referenceValueSize / 3;\n\n\t\t}\n\n\t\tlet targetOffset = 0;\n\t\tconst targetValueSize = targetTrack.getValueSize();\n\n\t\tif ( targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {\n\n\t\t\ttargetOffset = targetValueSize / 3;\n\n\t\t}\n\n\t\tconst lastIndex = referenceTrack.times.length - 1;\n\t\tlet referenceValue;\n\n\t\t// Find the value to subtract out of the track\n\t\tif ( referenceTime <= referenceTrack.times[ 0 ] ) {\n\n\t\t\t// Reference frame is earlier than the first keyframe, so just use the first keyframe\n\t\t\tconst startIndex = referenceOffset;\n\t\t\tconst endIndex = referenceValueSize - referenceOffset;\n\t\t\treferenceValue = referenceTrack.values.slice( startIndex, endIndex );\n\n\t\t} else if ( referenceTime >= referenceTrack.times[ lastIndex ] ) {\n\n\t\t\t// Reference frame is after the last keyframe, so just use the last keyframe\n\t\t\tconst startIndex = lastIndex * referenceValueSize + referenceOffset;\n\t\t\tconst endIndex = startIndex + referenceValueSize - referenceOffset;\n\t\t\treferenceValue = referenceTrack.values.slice( startIndex, endIndex );\n\n\t\t} else {\n\n\t\t\t// Interpolate to the reference value\n\t\t\tconst interpolant = referenceTrack.createInterpolant();\n\t\t\tconst startIndex = referenceOffset;\n\t\t\tconst endIndex = referenceValueSize - referenceOffset;\n\t\t\tinterpolant.evaluate( referenceTime );\n\t\t\treferenceValue = interpolant.resultBuffer.slice( startIndex, endIndex );\n\n\t\t}\n\n\t\t// Conjugate the quaternion\n\t\tif ( referenceTrackType === 'quaternion' ) {\n\n\t\t\tconst referenceQuat = new Quaternion().fromArray( referenceValue ).normalize().conjugate();\n\t\t\treferenceQuat.toArray( referenceValue );\n\n\t\t}\n\n\t\t// Subtract the reference value from all of the track values\n\n\t\tconst numTimes = targetTrack.times.length;\n\t\tfor ( let j = 0; j < numTimes; ++ j ) {\n\n\t\t\tconst valueStart = j * targetValueSize + targetOffset;\n\n\t\t\tif ( referenceTrackType === 'quaternion' ) {\n\n\t\t\t\t// Multiply the conjugate for quaternion track types\n\t\t\t\tQuaternion.multiplyQuaternionsFlat(\n\t\t\t\t\ttargetTrack.values,\n\t\t\t\t\tvalueStart,\n\t\t\t\t\treferenceValue,\n\t\t\t\t\t0,\n\t\t\t\t\ttargetTrack.values,\n\t\t\t\t\tvalueStart\n\t\t\t\t);\n\n\t\t\t} else {\n\n\t\t\t\tconst valueEnd = targetValueSize - targetOffset * 2;\n\n\t\t\t\t// Subtract each value for all other numeric track types\n\t\t\t\tfor ( let k = 0; k < valueEnd; ++ k ) {\n\n\t\t\t\t\ttargetTrack.values[ valueStart + k ] -= referenceValue[ k ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttargetClip.blendMode = AdditiveAnimationBlendMode;\n\n\treturn targetClip;\n\n}\n\nconst AnimationUtils = {\n\tconvertArray: convertArray,\n\tisTypedArray: isTypedArray,\n\tgetKeyframeOrder: getKeyframeOrder,\n\tsortedArray: sortedArray,\n\tflattenJSON: flattenJSON,\n\tsubclip: subclip,\n\tmakeClipAdditive: makeClipAdditive\n};\n\nexport {\n\tconvertArray,\n\tisTypedArray,\n\tgetKeyframeOrder,\n\tsortedArray,\n\tflattenJSON,\n\tsubclip,\n\tmakeClipAdditive,\n\tAnimationUtils\n};\n", "import { ZeroCurvatureEnding, WrapAroundEnding, ZeroSlopeEnding } from '../../constants.js';\nimport { Interpolant } from '../Interpolant.js';\n\n/**\n * Fast and simple cubic spline interpolant.\n *\n * It was derived from a Hermitian construction setting the first derivative\n * at each sample position to the linear slope between neighboring positions\n * over their parameter interval.\n */\n\nclass CubicInterpolant extends Interpolant {\n\n\tconstructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tsuper( parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\t\tthis._weightPrev = - 0;\n\t\tthis._offsetPrev = - 0;\n\t\tthis._weightNext = - 0;\n\t\tthis._offsetNext = - 0;\n\n\t\tthis.DefaultSettings_ = {\n\n\t\t\tendingStart: ZeroCurvatureEnding,\n\t\t\tendingEnd: ZeroCurvatureEnding\n\n\t\t};\n\n\t}\n\n\tintervalChanged_( i1, t0, t1 ) {\n\n\t\tconst pp = this.parameterPositions;\n\t\tlet iPrev = i1 - 2,\n\t\t\tiNext = i1 + 1,\n\n\t\t\ttPrev = pp[ iPrev ],\n\t\t\ttNext = pp[ iNext ];\n\n\t\tif ( tPrev === undefined ) {\n\n\t\t\tswitch ( this.getSettings_().endingStart ) {\n\n\t\t\t\tcase ZeroSlopeEnding:\n\n\t\t\t\t\t// f'(t0) = 0\n\t\t\t\t\tiPrev = i1;\n\t\t\t\t\ttPrev = 2 * t0 - t1;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase WrapAroundEnding:\n\n\t\t\t\t\t// use the other end of the curve\n\t\t\t\t\tiPrev = pp.length - 2;\n\t\t\t\t\ttPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault: // ZeroCurvatureEnding\n\n\t\t\t\t\t// f''(t0) = 0 a.k.a. Natural Spline\n\t\t\t\t\tiPrev = i1;\n\t\t\t\t\ttPrev = t1;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( tNext === undefined ) {\n\n\t\t\tswitch ( this.getSettings_().endingEnd ) {\n\n\t\t\t\tcase ZeroSlopeEnding:\n\n\t\t\t\t\t// f'(tN) = 0\n\t\t\t\t\tiNext = i1;\n\t\t\t\t\ttNext = 2 * t1 - t0;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase WrapAroundEnding:\n\n\t\t\t\t\t// use the other end of the curve\n\t\t\t\t\tiNext = 1;\n\t\t\t\t\ttNext = t1 + pp[ 1 ] - pp[ 0 ];\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault: // ZeroCurvatureEnding\n\n\t\t\t\t\t// f''(tN) = 0, a.k.a. Natural Spline\n\t\t\t\t\tiNext = i1 - 1;\n\t\t\t\t\ttNext = t0;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst halfDt = ( t1 - t0 ) * 0.5,\n\t\t\tstride = this.valueSize;\n\n\t\tthis._weightPrev = halfDt / ( t0 - tPrev );\n\t\tthis._weightNext = halfDt / ( tNext - t1 );\n\t\tthis._offsetPrev = iPrev * stride;\n\t\tthis._offsetNext = iNext * stride;\n\n\t}\n\n\tinterpolate_( i1, t0, t, t1 ) {\n\n\t\tconst result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tstride = this.valueSize,\n\n\t\t\to1 = i1 * stride,\t\to0 = o1 - stride,\n\t\t\toP = this._offsetPrev, \toN = this._offsetNext,\n\t\t\twP = this._weightPrev,\twN = this._weightNext,\n\n\t\t\tp = ( t - t0 ) / ( t1 - t0 ),\n\t\t\tpp = p * p,\n\t\t\tppp = pp * p;\n\n\t\t// evaluate polynomials\n\n\t\tconst sP = - wP * ppp + 2 * wP * pp - wP * p;\n\t\tconst s0 = ( 1 + wP ) * ppp + ( - 1.5 - 2 * wP ) * pp + ( - 0.5 + wP ) * p + 1;\n\t\tconst s1 = ( - 1 - wN ) * ppp + ( 1.5 + wN ) * pp + 0.5 * p;\n\t\tconst sN = wN * ppp - wN * pp;\n\n\t\t// combine data linearly\n\n\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\tresult[ i ] =\n\t\t\t\t\tsP * values[ oP + i ] +\n\t\t\t\t\ts0 * values[ o0 + i ] +\n\t\t\t\t\ts1 * values[ o1 + i ] +\n\t\t\t\t\tsN * values[ oN + i ];\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n}\n\nexport { CubicInterpolant };\n", "import { Interpolant } from '../Interpolant.js';\n\n/**\n *\n * Interpolant that evaluates to the sample value at the position preceding\n * the parameter.\n */\n\nclass DiscreteInterpolant extends Interpolant {\n\n\tconstructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tsuper( parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\t}\n\n\tinterpolate_( i1 /*, t0, t, t1 */ ) {\n\n\t\treturn this.copySampleValue_( i1 - 1 );\n\n\t}\n\n}\n\n\nexport { DiscreteInterpolant };\n", "import {\n\tInterpolateLinear,\n\tInterpolateSmooth,\n\tInterpolateDiscrete\n} from '../constants.js';\nimport { CubicInterpolant } from '../math/interpolants/CubicInterpolant.js';\nimport { LinearInterpolant } from '../math/interpolants/LinearInterpolant.js';\nimport { DiscreteInterpolant } from '../math/interpolants/DiscreteInterpolant.js';\nimport * as AnimationUtils from './AnimationUtils.js';\n\nclass KeyframeTrack {\n\n\tconstructor( name, times, values, interpolation ) {\n\n\t\tif ( name === undefined ) throw new Error( 'THREE.KeyframeTrack: track name is undefined' );\n\t\tif ( times === undefined || times.length === 0 ) throw new Error( 'THREE.KeyframeTrack: no keyframes in track named ' + name );\n\n\t\tthis.name = name;\n\n\t\tthis.times = AnimationUtils.convertArray( times, this.TimeBufferType );\n\t\tthis.values = AnimationUtils.convertArray( values, this.ValueBufferType );\n\n\t\tthis.setInterpolation( interpolation || this.DefaultInterpolation );\n\n\t}\n\n\t// Serialization (in static context, because of constructor invocation\n\t// and automatic invocation of .toJSON):\n\n\tstatic toJSON( track ) {\n\n\t\tconst trackType = track.constructor;\n\n\t\tlet json;\n\n\t\t// derived classes can define a static toJSON method\n\t\tif ( trackType.toJSON !== this.toJSON ) {\n\n\t\t\tjson = trackType.toJSON( track );\n\n\t\t} else {\n\n\t\t\t// by default, we assume the data can be serialized as-is\n\t\t\tjson = {\n\n\t\t\t\t'name': track.name,\n\t\t\t\t'times': AnimationUtils.convertArray( track.times, Array ),\n\t\t\t\t'values': AnimationUtils.convertArray( track.values, Array )\n\n\t\t\t};\n\n\t\t\tconst interpolation = track.getInterpolation();\n\n\t\t\tif ( interpolation !== track.DefaultInterpolation ) {\n\n\t\t\t\tjson.interpolation = interpolation;\n\n\t\t\t}\n\n\t\t}\n\n\t\tjson.type = track.ValueTypeName; // mandatory\n\n\t\treturn json;\n\n\t}\n\n\tInterpolantFactoryMethodDiscrete( result ) {\n\n\t\treturn new DiscreteInterpolant( this.times, this.values, this.getValueSize(), result );\n\n\t}\n\n\tInterpolantFactoryMethodLinear( result ) {\n\n\t\treturn new LinearInterpolant( this.times, this.values, this.getValueSize(), result );\n\n\t}\n\n\tInterpolantFactoryMethodSmooth( result ) {\n\n\t\treturn new CubicInterpolant( this.times, this.values, this.getValueSize(), result );\n\n\t}\n\n\tsetInterpolation( interpolation ) {\n\n\t\tlet factoryMethod;\n\n\t\tswitch ( interpolation ) {\n\n\t\t\tcase InterpolateDiscrete:\n\n\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodDiscrete;\n\n\t\t\t\tbreak;\n\n\t\t\tcase InterpolateLinear:\n\n\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodLinear;\n\n\t\t\t\tbreak;\n\n\t\t\tcase InterpolateSmooth:\n\n\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodSmooth;\n\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tif ( factoryMethod === undefined ) {\n\n\t\t\tconst message = 'unsupported interpolation for ' +\n\t\t\t\tthis.ValueTypeName + ' keyframe track named ' + this.name;\n\n\t\t\tif ( this.createInterpolant === undefined ) {\n\n\t\t\t\t// fall back to default, unless the default itself is messed up\n\t\t\t\tif ( interpolation !== this.DefaultInterpolation ) {\n\n\t\t\t\t\tthis.setInterpolation( this.DefaultInterpolation );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( message ); // fatal, in this case\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconsole.warn( 'THREE.KeyframeTrack:', message );\n\t\t\treturn this;\n\n\t\t}\n\n\t\tthis.createInterpolant = factoryMethod;\n\n\t\treturn this;\n\n\t}\n\n\tgetInterpolation() {\n\n\t\tswitch ( this.createInterpolant ) {\n\n\t\t\tcase this.InterpolantFactoryMethodDiscrete:\n\n\t\t\t\treturn InterpolateDiscrete;\n\n\t\t\tcase this.InterpolantFactoryMethodLinear:\n\n\t\t\t\treturn InterpolateLinear;\n\n\t\t\tcase this.InterpolantFactoryMethodSmooth:\n\n\t\t\t\treturn InterpolateSmooth;\n\n\t\t}\n\n\t}\n\n\tgetValueSize() {\n\n\t\treturn this.values.length / this.times.length;\n\n\t}\n\n\t// move all keyframes either forwards or backwards in time\n\tshift( timeOffset ) {\n\n\t\tif ( timeOffset !== 0.0 ) {\n\n\t\t\tconst times = this.times;\n\n\t\t\tfor ( let i = 0, n = times.length; i !== n; ++ i ) {\n\n\t\t\t\ttimes[ i ] += timeOffset;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// scale all keyframe times by a factor (useful for frame <-> seconds conversions)\n\tscale( timeScale ) {\n\n\t\tif ( timeScale !== 1.0 ) {\n\n\t\t\tconst times = this.times;\n\n\t\t\tfor ( let i = 0, n = times.length; i !== n; ++ i ) {\n\n\t\t\t\ttimes[ i ] *= timeScale;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// removes keyframes before and after animation without changing any values within the range [startTime, endTime].\n\t// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values\n\ttrim( startTime, endTime ) {\n\n\t\tconst times = this.times,\n\t\t\tnKeys = times.length;\n\n\t\tlet from = 0,\n\t\t\tto = nKeys - 1;\n\n\t\twhile ( from !== nKeys && times[ from ] < startTime ) {\n\n\t\t\t++ from;\n\n\t\t}\n\n\t\twhile ( to !== - 1 && times[ to ] > endTime ) {\n\n\t\t\t-- to;\n\n\t\t}\n\n\t\t++ to; // inclusive -> exclusive bound\n\n\t\tif ( from !== 0 || to !== nKeys ) {\n\n\t\t\t// empty tracks are forbidden, so keep at least one keyframe\n\t\t\tif ( from >= to ) {\n\n\t\t\t\tto = Math.max( to, 1 );\n\t\t\t\tfrom = to - 1;\n\n\t\t\t}\n\n\t\t\tconst stride = this.getValueSize();\n\t\t\tthis.times = times.slice( from, to );\n\t\t\tthis.values = this.values.slice( from * stride, to * stride );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable\n\tvalidate() {\n\n\t\tlet valid = true;\n\n\t\tconst valueSize = this.getValueSize();\n\t\tif ( valueSize - Math.floor( valueSize ) !== 0 ) {\n\n\t\t\tconsole.error( 'THREE.KeyframeTrack: Invalid value size in track.', this );\n\t\t\tvalid = false;\n\n\t\t}\n\n\t\tconst times = this.times,\n\t\t\tvalues = this.values,\n\n\t\t\tnKeys = times.length;\n\n\t\tif ( nKeys === 0 ) {\n\n\t\t\tconsole.error( 'THREE.KeyframeTrack: Track is empty.', this );\n\t\t\tvalid = false;\n\n\t\t}\n\n\t\tlet prevTime = null;\n\n\t\tfor ( let i = 0; i !== nKeys; i ++ ) {\n\n\t\t\tconst currTime = times[ i ];\n\n\t\t\tif ( typeof currTime === 'number' && isNaN( currTime ) ) {\n\n\t\t\t\tconsole.error( 'THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime );\n\t\t\t\tvalid = false;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( prevTime !== null && prevTime > currTime ) {\n\n\t\t\t\tconsole.error( 'THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime );\n\t\t\t\tvalid = false;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tprevTime = currTime;\n\n\t\t}\n\n\t\tif ( values !== undefined ) {\n\n\t\t\tif ( AnimationUtils.isTypedArray( values ) ) {\n\n\t\t\t\tfor ( let i = 0, n = values.length; i !== n; ++ i ) {\n\n\t\t\t\t\tconst value = values[ i ];\n\n\t\t\t\t\tif ( isNaN( value ) ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.KeyframeTrack: Value is not a valid number.', this, i, value );\n\t\t\t\t\t\tvalid = false;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn valid;\n\n\t}\n\n\t// removes equivalent sequential keys as common in morph target sequences\n\t// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)\n\toptimize() {\n\n\t\t// times or values may be shared with other tracks, so overwriting is unsafe\n\t\tconst times = this.times.slice(),\n\t\t\tvalues = this.values.slice(),\n\t\t\tstride = this.getValueSize(),\n\n\t\t\tsmoothInterpolation = this.getInterpolation() === InterpolateSmooth,\n\n\t\t\tlastIndex = times.length - 1;\n\n\t\tlet writeIndex = 1;\n\n\t\tfor ( let i = 1; i < lastIndex; ++ i ) {\n\n\t\t\tlet keep = false;\n\n\t\t\tconst time = times[ i ];\n\t\t\tconst timeNext = times[ i + 1 ];\n\n\t\t\t// remove adjacent keyframes scheduled at the same time\n\n\t\t\tif ( time !== timeNext && ( i !== 1 || time !== times[ 0 ] ) ) {\n\n\t\t\t\tif ( ! smoothInterpolation ) {\n\n\t\t\t\t\t// remove unnecessary keyframes same as their neighbors\n\n\t\t\t\t\tconst offset = i * stride,\n\t\t\t\t\t\toffsetP = offset - stride,\n\t\t\t\t\t\toffsetN = offset + stride;\n\n\t\t\t\t\tfor ( let j = 0; j !== stride; ++ j ) {\n\n\t\t\t\t\t\tconst value = values[ offset + j ];\n\n\t\t\t\t\t\tif ( value !== values[ offsetP + j ] ||\n\t\t\t\t\t\t\tvalue !== values[ offsetN + j ] ) {\n\n\t\t\t\t\t\t\tkeep = true;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tkeep = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// in-place compaction\n\n\t\t\tif ( keep ) {\n\n\t\t\t\tif ( i !== writeIndex ) {\n\n\t\t\t\t\ttimes[ writeIndex ] = times[ i ];\n\n\t\t\t\t\tconst readOffset = i * stride,\n\t\t\t\t\t\twriteOffset = writeIndex * stride;\n\n\t\t\t\t\tfor ( let j = 0; j !== stride; ++ j ) {\n\n\t\t\t\t\t\tvalues[ writeOffset + j ] = values[ readOffset + j ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t++ writeIndex;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// flush last keyframe (compaction looks ahead)\n\n\t\tif ( lastIndex > 0 ) {\n\n\t\t\ttimes[ writeIndex ] = times[ lastIndex ];\n\n\t\t\tfor ( let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j ) {\n\n\t\t\t\tvalues[ writeOffset + j ] = values[ readOffset + j ];\n\n\t\t\t}\n\n\t\t\t++ writeIndex;\n\n\t\t}\n\n\t\tif ( writeIndex !== times.length ) {\n\n\t\t\tthis.times = times.slice( 0, writeIndex );\n\t\t\tthis.values = values.slice( 0, writeIndex * stride );\n\n\t\t} else {\n\n\t\t\tthis.times = times;\n\t\t\tthis.values = values;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\tconst times = this.times.slice();\n\t\tconst values = this.values.slice();\n\n\t\tconst TypedKeyframeTrack = this.constructor;\n\t\tconst track = new TypedKeyframeTrack( this.name, times, values );\n\n\t\t// Interpolant argument to constructor is not saved, so copy the factory method directly.\n\t\ttrack.createInterpolant = this.createInterpolant;\n\n\t\treturn track;\n\n\t}\n\n}\n\nKeyframeTrack.prototype.TimeBufferType = Float32Array;\nKeyframeTrack.prototype.ValueBufferType = Float32Array;\nKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;\n\nexport { KeyframeTrack };\n", "import { InterpolateDiscrete } from '../../constants.js';\nimport { KeyframeTrack } from '../KeyframeTrack.js';\n\n/**\n * A Track of Boolean keyframe values.\n */\nclass BooleanKeyframeTrack extends KeyframeTrack {\n\n\t// No interpolation parameter because only InterpolateDiscrete is valid.\n\tconstructor( name, times, values ) {\n\n\t\tsuper( name, times, values );\n\n\t}\n\n}\n\nBooleanKeyframeTrack.prototype.ValueTypeName = 'bool';\nBooleanKeyframeTrack.prototype.ValueBufferType = Array;\nBooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;\nBooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;\nBooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;\n\n// Note: Actually this track could have a optimized / compressed\n// representation of a single value and a custom interpolant that\n// computes \"firstValue ^ isOdd( index )\".\n\nexport { BooleanKeyframeTrack };\n", "import { KeyframeTrack } from '../KeyframeTrack.js';\n\n/**\n * A Track of keyframe values that represent color.\n */\nclass ColorKeyframeTrack extends KeyframeTrack {}\n\nColorKeyframeTrack.prototype.ValueTypeName = 'color';\n// ValueBufferType is inherited\n// DefaultInterpolation is inherited\n\n// Note: Very basic implementation and nothing special yet.\n// However, this is the place for color space parameterization.\n\nexport { ColorKeyframeTrack };\n", "import { KeyframeTrack } from '../KeyframeTrack.js';\n\n/**\n * A Track of numeric keyframe values.\n */\nclass NumberKeyframeTrack extends KeyframeTrack {}\n\nNumberKeyframeTrack.prototype.ValueTypeName = 'number';\n// ValueBufferType is inherited\n// DefaultInterpolation is inherited\n\nexport { NumberKeyframeTrack };\n", "import { Interpolant } from '../Interpolant.js';\nimport { Quaternion } from '../Quaternion.js';\n\n/**\n * Spherical linear unit quaternion interpolant.\n */\n\nclass QuaternionLinearInterpolant extends Interpolant {\n\n\tconstructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tsuper( parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\t}\n\n\tinterpolate_( i1, t0, t, t1 ) {\n\n\t\tconst result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tstride = this.valueSize,\n\n\t\t\talpha = ( t - t0 ) / ( t1 - t0 );\n\n\t\tlet offset = i1 * stride;\n\n\t\tfor ( let end = offset + stride; offset !== end; offset += 4 ) {\n\n\t\t\tQuaternion.slerpFlat( result, 0, values, offset - stride, values, offset, alpha );\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n}\n\n\nexport { QuaternionLinearInterpolant };\n", "import { KeyframeTrack } from '../KeyframeTrack.js';\nimport { QuaternionLinearInterpolant } from '../../math/interpolants/QuaternionLinearInterpolant.js';\n\n/**\n * A Track of quaternion keyframe values.\n */\nclass QuaternionKeyframeTrack extends KeyframeTrack {\n\n\tInterpolantFactoryMethodLinear( result ) {\n\n\t\treturn new QuaternionLinearInterpolant( this.times, this.values, this.getValueSize(), result );\n\n\t}\n\n}\n\nQuaternionKeyframeTrack.prototype.ValueTypeName = 'quaternion';\n// ValueBufferType is inherited\n// DefaultInterpolation is inherited;\nQuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;\n\nexport { QuaternionKeyframeTrack };\n", "import { InterpolateDiscrete } from '../../constants.js';\nimport { KeyframeTrack } from '../KeyframeTrack.js';\n\n/**\n * A Track that interpolates Strings\n */\nclass StringKeyframeTrack extends KeyframeTrack {\n\n\t// No interpolation parameter because only InterpolateDiscrete is valid.\n\tconstructor( name, times, values ) {\n\n\t\tsuper( name, times, values );\n\n\t}\n\n}\n\nStringKeyframeTrack.prototype.ValueTypeName = 'string';\nStringKeyframeTrack.prototype.ValueBufferType = Array;\nStringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;\nStringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;\nStringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;\n\nexport { StringKeyframeTrack };\n", "import { KeyframeTrack } from '../KeyframeTrack.js';\n\n/**\n * A Track of vectored keyframe values.\n */\nclass VectorKeyframeTrack extends KeyframeTrack {}\n\nVectorKeyframeTrack.prototype.ValueTypeName = 'vector';\n// ValueBufferType is inherited\n// DefaultInterpolation is inherited\n\nexport { VectorKeyframeTrack };\n", "import * as AnimationUtils from './AnimationUtils.js';\nimport { KeyframeTrack } from './KeyframeTrack.js';\nimport { BooleanKeyframeTrack } from './tracks/BooleanKeyframeTrack.js';\nimport { ColorKeyframeTrack } from './tracks/ColorKeyframeTrack.js';\nimport { NumberKeyframeTrack } from './tracks/NumberKeyframeTrack.js';\nimport { QuaternionKeyframeTrack } from './tracks/QuaternionKeyframeTrack.js';\nimport { StringKeyframeTrack } from './tracks/StringKeyframeTrack.js';\nimport { VectorKeyframeTrack } from './tracks/VectorKeyframeTrack.js';\nimport * as MathUtils from '../math/MathUtils.js';\nimport { NormalAnimationBlendMode } from '../constants.js';\n\nclass AnimationClip {\n\n\tconstructor( name = '', duration = - 1, tracks = [], blendMode = NormalAnimationBlendMode ) {\n\n\t\tthis.name = name;\n\t\tthis.tracks = tracks;\n\t\tthis.duration = duration;\n\t\tthis.blendMode = blendMode;\n\n\t\tthis.uuid = MathUtils.generateUUID();\n\n\t\t// this means it should figure out its duration by scanning the tracks\n\t\tif ( this.duration < 0 ) {\n\n\t\t\tthis.resetDuration();\n\n\t\t}\n\n\t}\n\n\n\tstatic parse( json ) {\n\n\t\tconst tracks = [],\n\t\t\tjsonTracks = json.tracks,\n\t\t\tframeTime = 1.0 / ( json.fps || 1.0 );\n\n\t\tfor ( let i = 0, n = jsonTracks.length; i !== n; ++ i ) {\n\n\t\t\ttracks.push( parseKeyframeTrack( jsonTracks[ i ] ).scale( frameTime ) );\n\n\t\t}\n\n\t\tconst clip = new this( json.name, json.duration, tracks, json.blendMode );\n\t\tclip.uuid = json.uuid;\n\n\t\treturn clip;\n\n\t}\n\n\tstatic toJSON( clip ) {\n\n\t\tconst tracks = [],\n\t\t\tclipTracks = clip.tracks;\n\n\t\tconst json = {\n\n\t\t\t'name': clip.name,\n\t\t\t'duration': clip.duration,\n\t\t\t'tracks': tracks,\n\t\t\t'uuid': clip.uuid,\n\t\t\t'blendMode': clip.blendMode\n\n\t\t};\n\n\t\tfor ( let i = 0, n = clipTracks.length; i !== n; ++ i ) {\n\n\t\t\ttracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );\n\n\t\t}\n\n\t\treturn json;\n\n\t}\n\n\tstatic CreateFromMorphTargetSequence( name, morphTargetSequence, fps, noLoop ) {\n\n\t\tconst numMorphTargets = morphTargetSequence.length;\n\t\tconst tracks = [];\n\n\t\tfor ( let i = 0; i < numMorphTargets; i ++ ) {\n\n\t\t\tlet times = [];\n\t\t\tlet values = [];\n\n\t\t\ttimes.push(\n\t\t\t\t( i + numMorphTargets - 1 ) % numMorphTargets,\n\t\t\t\ti,\n\t\t\t\t( i + 1 ) % numMorphTargets );\n\n\t\t\tvalues.push( 0, 1, 0 );\n\n\t\t\tconst order = AnimationUtils.getKeyframeOrder( times );\n\t\t\ttimes = AnimationUtils.sortedArray( times, 1, order );\n\t\t\tvalues = AnimationUtils.sortedArray( values, 1, order );\n\n\t\t\t// if there is a key at the first frame, duplicate it as the\n\t\t\t// last frame as well for perfect loop.\n\t\t\tif ( ! noLoop && times[ 0 ] === 0 ) {\n\n\t\t\t\ttimes.push( numMorphTargets );\n\t\t\t\tvalues.push( values[ 0 ] );\n\n\t\t\t}\n\n\t\t\ttracks.push(\n\t\t\t\tnew NumberKeyframeTrack(\n\t\t\t\t\t'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',\n\t\t\t\t\ttimes, values\n\t\t\t\t).scale( 1.0 / fps ) );\n\n\t\t}\n\n\t\treturn new this( name, - 1, tracks );\n\n\t}\n\n\tstatic findByName( objectOrClipArray, name ) {\n\n\t\tlet clipArray = objectOrClipArray;\n\n\t\tif ( ! Array.isArray( objectOrClipArray ) ) {\n\n\t\t\tconst o = objectOrClipArray;\n\t\t\tclipArray = o.geometry && o.geometry.animations || o.animations;\n\n\t\t}\n\n\t\tfor ( let i = 0; i < clipArray.length; i ++ ) {\n\n\t\t\tif ( clipArray[ i ].name === name ) {\n\n\t\t\t\treturn clipArray[ i ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\tstatic CreateClipsFromMorphTargetSequences( morphTargets, fps, noLoop ) {\n\n\t\tconst animationToMorphTargets = {};\n\n\t\t// tested with https://regex101.com/ on trick sequences\n\t\t// such flamingo_flyA_003, flamingo_run1_003, crdeath0059\n\t\tconst pattern = /^([\\w-]*?)([\\d]+)$/;\n\n\t\t// sort morph target names into animation groups based\n\t\t// patterns like Walk_001, Walk_002, Run_001, Run_002\n\t\tfor ( let i = 0, il = morphTargets.length; i < il; i ++ ) {\n\n\t\t\tconst morphTarget = morphTargets[ i ];\n\t\t\tconst parts = morphTarget.name.match( pattern );\n\n\t\t\tif ( parts && parts.length > 1 ) {\n\n\t\t\t\tconst name = parts[ 1 ];\n\n\t\t\t\tlet animationMorphTargets = animationToMorphTargets[ name ];\n\n\t\t\t\tif ( ! animationMorphTargets ) {\n\n\t\t\t\t\tanimationToMorphTargets[ name ] = animationMorphTargets = [];\n\n\t\t\t\t}\n\n\t\t\t\tanimationMorphTargets.push( morphTarget );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst clips = [];\n\n\t\tfor ( const name in animationToMorphTargets ) {\n\n\t\t\tclips.push( this.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );\n\n\t\t}\n\n\t\treturn clips;\n\n\t}\n\n\t// parse the animation.hierarchy format\n\tstatic parseAnimation( animation, bones ) {\n\n\t\tif ( ! animation ) {\n\n\t\t\tconsole.error( 'THREE.AnimationClip: No animation in JSONLoader data.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst addNonemptyTrack = function ( trackType, trackName, animationKeys, propertyName, destTracks ) {\n\n\t\t\t// only return track if there are actually keys.\n\t\t\tif ( animationKeys.length !== 0 ) {\n\n\t\t\t\tconst times = [];\n\t\t\t\tconst values = [];\n\n\t\t\t\tAnimationUtils.flattenJSON( animationKeys, times, values, propertyName );\n\n\t\t\t\t// empty keys are filtered out, so check again\n\t\t\t\tif ( times.length !== 0 ) {\n\n\t\t\t\t\tdestTracks.push( new trackType( trackName, times, values ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\tconst tracks = [];\n\n\t\tconst clipName = animation.name || 'default';\n\t\tconst fps = animation.fps || 30;\n\t\tconst blendMode = animation.blendMode;\n\n\t\t// automatic length determination in AnimationClip.\n\t\tlet duration = animation.length || - 1;\n\n\t\tconst hierarchyTracks = animation.hierarchy || [];\n\n\t\tfor ( let h = 0; h < hierarchyTracks.length; h ++ ) {\n\n\t\t\tconst animationKeys = hierarchyTracks[ h ].keys;\n\n\t\t\t// skip empty tracks\n\t\t\tif ( ! animationKeys || animationKeys.length === 0 ) continue;\n\n\t\t\t// process morph targets\n\t\t\tif ( animationKeys[ 0 ].morphTargets ) {\n\n\t\t\t\t// figure out all morph targets used in this track\n\t\t\t\tconst morphTargetNames = {};\n\n\t\t\t\tlet k;\n\n\t\t\t\tfor ( k = 0; k < animationKeys.length; k ++ ) {\n\n\t\t\t\t\tif ( animationKeys[ k ].morphTargets ) {\n\n\t\t\t\t\t\tfor ( let m = 0; m < animationKeys[ k ].morphTargets.length; m ++ ) {\n\n\t\t\t\t\t\t\tmorphTargetNames[ animationKeys[ k ].morphTargets[ m ] ] = - 1;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// create a track for each morph target with all zero\n\t\t\t\t// morphTargetInfluences except for the keys in which\n\t\t\t\t// the morphTarget is named.\n\t\t\t\tfor ( const morphTargetName in morphTargetNames ) {\n\n\t\t\t\t\tconst times = [];\n\t\t\t\t\tconst values = [];\n\n\t\t\t\t\tfor ( let m = 0; m !== animationKeys[ k ].morphTargets.length; ++ m ) {\n\n\t\t\t\t\t\tconst animationKey = animationKeys[ k ];\n\n\t\t\t\t\t\ttimes.push( animationKey.time );\n\t\t\t\t\t\tvalues.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttracks.push( new NumberKeyframeTrack( '.morphTargetInfluence[' + morphTargetName + ']', times, values ) );\n\n\t\t\t\t}\n\n\t\t\t\tduration = morphTargetNames.length * fps;\n\n\t\t\t} else {\n\n\t\t\t\t// ...assume skeletal animation\n\n\t\t\t\tconst boneName = '.bones[' + bones[ h ].name + ']';\n\n\t\t\t\taddNonemptyTrack(\n\t\t\t\t\tVectorKeyframeTrack, boneName + '.position',\n\t\t\t\t\tanimationKeys, 'pos', tracks );\n\n\t\t\t\taddNonemptyTrack(\n\t\t\t\t\tQuaternionKeyframeTrack, boneName + '.quaternion',\n\t\t\t\t\tanimationKeys, 'rot', tracks );\n\n\t\t\t\taddNonemptyTrack(\n\t\t\t\t\tVectorKeyframeTrack, boneName + '.scale',\n\t\t\t\t\tanimationKeys, 'scl', tracks );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( tracks.length === 0 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst clip = new this( clipName, duration, tracks, blendMode );\n\n\t\treturn clip;\n\n\t}\n\n\tresetDuration() {\n\n\t\tconst tracks = this.tracks;\n\t\tlet duration = 0;\n\n\t\tfor ( let i = 0, n = tracks.length; i !== n; ++ i ) {\n\n\t\t\tconst track = this.tracks[ i ];\n\n\t\t\tduration = Math.max( duration, track.times[ track.times.length - 1 ] );\n\n\t\t}\n\n\t\tthis.duration = duration;\n\n\t\treturn this;\n\n\t}\n\n\ttrim() {\n\n\t\tfor ( let i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\tthis.tracks[ i ].trim( 0, this.duration );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tvalidate() {\n\n\t\tlet valid = true;\n\n\t\tfor ( let i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\tvalid = valid && this.tracks[ i ].validate();\n\n\t\t}\n\n\t\treturn valid;\n\n\t}\n\n\toptimize() {\n\n\t\tfor ( let i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\tthis.tracks[ i ].optimize();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\tconst tracks = [];\n\n\t\tfor ( let i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\ttracks.push( this.tracks[ i ].clone() );\n\n\t\t}\n\n\t\treturn new this.constructor( this.name, this.duration, tracks, this.blendMode );\n\n\t}\n\n\ttoJSON() {\n\n\t\treturn this.constructor.toJSON( this );\n\n\t}\n\n}\n\nfunction getTrackTypeForValueTypeName( typeName ) {\n\n\tswitch ( typeName.toLowerCase() ) {\n\n\t\tcase 'scalar':\n\t\tcase 'double':\n\t\tcase 'float':\n\t\tcase 'number':\n\t\tcase 'integer':\n\n\t\t\treturn NumberKeyframeTrack;\n\n\t\tcase 'vector':\n\t\tcase 'vector2':\n\t\tcase 'vector3':\n\t\tcase 'vector4':\n\n\t\t\treturn VectorKeyframeTrack;\n\n\t\tcase 'color':\n\n\t\t\treturn ColorKeyframeTrack;\n\n\t\tcase 'quaternion':\n\n\t\t\treturn QuaternionKeyframeTrack;\n\n\t\tcase 'bool':\n\t\tcase 'boolean':\n\n\t\t\treturn BooleanKeyframeTrack;\n\n\t\tcase 'string':\n\n\t\t\treturn StringKeyframeTrack;\n\n\t}\n\n\tthrow new Error( 'THREE.KeyframeTrack: Unsupported typeName: ' + typeName );\n\n}\n\nfunction parseKeyframeTrack( json ) {\n\n\tif ( json.type === undefined ) {\n\n\t\tthrow new Error( 'THREE.KeyframeTrack: track type undefined, can not parse' );\n\n\t}\n\n\tconst trackType = getTrackTypeForValueTypeName( json.type );\n\n\tif ( json.times === undefined ) {\n\n\t\tconst times = [], values = [];\n\n\t\tAnimationUtils.flattenJSON( json.keys, times, values, 'value' );\n\n\t\tjson.times = times;\n\t\tjson.values = values;\n\n\t}\n\n\t// derived classes can define a static parse method\n\tif ( trackType.parse !== undefined ) {\n\n\t\treturn trackType.parse( json );\n\n\t} else {\n\n\t\t// by default, we assume a constructor compatible with the base\n\t\treturn new trackType( json.name, json.times, json.values, json.interpolation );\n\n\t}\n\n}\n\nexport { AnimationClip };\n", "import { AnimationAction } from './AnimationAction.js';\nimport { EventDispatcher } from '../core/EventDispatcher.js';\nimport { LinearInterpolant } from '../math/interpolants/LinearInterpolant.js';\nimport { PropertyBinding } from './PropertyBinding.js';\nimport { PropertyMixer } from './PropertyMixer.js';\nimport { AnimationClip } from './AnimationClip.js';\nimport { NormalAnimationBlendMode } from '../constants.js';\n\n\nconst _controlInterpolantsResultBuffer = new Float32Array( 1 );\n\n\nclass AnimationMixer extends EventDispatcher {\n\n\tconstructor( root ) {\n\n\t\tsuper();\n\n\t\tthis._root = root;\n\t\tthis._initMemoryManager();\n\t\tthis._accuIndex = 0;\n\t\tthis.time = 0;\n\t\tthis.timeScale = 1.0;\n\n\t}\n\n\t_bindAction( action, prototypeAction ) {\n\n\t\tconst root = action._localRoot || this._root,\n\t\t\ttracks = action._clip.tracks,\n\t\t\tnTracks = tracks.length,\n\t\t\tbindings = action._propertyBindings,\n\t\t\tinterpolants = action._interpolants,\n\t\t\trootUuid = root.uuid,\n\t\t\tbindingsByRoot = this._bindingsByRootAndName;\n\n\t\tlet bindingsByName = bindingsByRoot[ rootUuid ];\n\n\t\tif ( bindingsByName === undefined ) {\n\n\t\t\tbindingsByName = {};\n\t\t\tbindingsByRoot[ rootUuid ] = bindingsByName;\n\n\t\t}\n\n\t\tfor ( let i = 0; i !== nTracks; ++ i ) {\n\n\t\t\tconst track = tracks[ i ],\n\t\t\t\ttrackName = track.name;\n\n\t\t\tlet binding = bindingsByName[ trackName ];\n\n\t\t\tif ( binding !== undefined ) {\n\n\t\t\t\t++ binding.referenceCount;\n\t\t\t\tbindings[ i ] = binding;\n\n\t\t\t} else {\n\n\t\t\t\tbinding = bindings[ i ];\n\n\t\t\t\tif ( binding !== undefined ) {\n\n\t\t\t\t\t// existing binding, make sure the cache knows\n\n\t\t\t\t\tif ( binding._cacheIndex === null ) {\n\n\t\t\t\t\t\t++ binding.referenceCount;\n\t\t\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tconst path = prototypeAction && prototypeAction.\n\t\t\t\t\t_propertyBindings[ i ].binding.parsedPath;\n\n\t\t\t\tbinding = new PropertyMixer(\n\t\t\t\t\tPropertyBinding.create( root, trackName, path ),\n\t\t\t\t\ttrack.ValueTypeName, track.getValueSize() );\n\n\t\t\t\t++ binding.referenceCount;\n\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\n\n\t\t\t\tbindings[ i ] = binding;\n\n\t\t\t}\n\n\t\t\tinterpolants[ i ].resultBuffer = binding.buffer;\n\n\t\t}\n\n\t}\n\n\t_activateAction( action ) {\n\n\t\tif ( ! this._isActiveAction( action ) ) {\n\n\t\t\tif ( action._cacheIndex === null ) {\n\n\t\t\t\t// this action has been forgotten by the cache, but the user\n\t\t\t\t// appears to be still using it -> rebind\n\n\t\t\t\tconst rootUuid = ( action._localRoot || this._root ).uuid,\n\t\t\t\t\tclipUuid = action._clip.uuid,\n\t\t\t\t\tactionsForClip = this._actionsByClip[ clipUuid ];\n\n\t\t\t\tthis._bindAction( action,\n\t\t\t\t\tactionsForClip && actionsForClip.knownActions[ 0 ] );\n\n\t\t\t\tthis._addInactiveAction( action, clipUuid, rootUuid );\n\n\t\t\t}\n\n\t\t\tconst bindings = action._propertyBindings;\n\n\t\t\t// increment reference counts / sort out state\n\t\t\tfor ( let i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\tconst binding = bindings[ i ];\n\n\t\t\t\tif ( binding.useCount ++ === 0 ) {\n\n\t\t\t\t\tthis._lendBinding( binding );\n\t\t\t\t\tbinding.saveOriginalState();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis._lendAction( action );\n\n\t\t}\n\n\t}\n\n\t_deactivateAction( action ) {\n\n\t\tif ( this._isActiveAction( action ) ) {\n\n\t\t\tconst bindings = action._propertyBindings;\n\n\t\t\t// decrement reference counts / sort out state\n\t\t\tfor ( let i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\tconst binding = bindings[ i ];\n\n\t\t\t\tif ( -- binding.useCount === 0 ) {\n\n\t\t\t\t\tbinding.restoreOriginalState();\n\t\t\t\t\tthis._takeBackBinding( binding );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis._takeBackAction( action );\n\n\t\t}\n\n\t}\n\n\t// Memory manager\n\n\t_initMemoryManager() {\n\n\t\tthis._actions = []; // 'nActiveActions' followed by inactive ones\n\t\tthis._nActiveActions = 0;\n\n\t\tthis._actionsByClip = {};\n\t\t// inside:\n\t\t// {\n\t\t// \tknownActions: Array< AnimationAction > - used as prototypes\n\t\t// \tactionByRoot: AnimationAction - lookup\n\t\t// }\n\n\n\t\tthis._bindings = []; // 'nActiveBindings' followed by inactive ones\n\t\tthis._nActiveBindings = 0;\n\n\t\tthis._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >\n\n\n\t\tthis._controlInterpolants = []; // same game as above\n\t\tthis._nActiveControlInterpolants = 0;\n\n\t\tconst scope = this;\n\n\t\tthis.stats = {\n\n\t\t\tactions: {\n\t\t\t\tget total() {\n\n\t\t\t\t\treturn scope._actions.length;\n\n\t\t\t\t},\n\t\t\t\tget inUse() {\n\n\t\t\t\t\treturn scope._nActiveActions;\n\n\t\t\t\t}\n\t\t\t},\n\t\t\tbindings: {\n\t\t\t\tget total() {\n\n\t\t\t\t\treturn scope._bindings.length;\n\n\t\t\t\t},\n\t\t\t\tget inUse() {\n\n\t\t\t\t\treturn scope._nActiveBindings;\n\n\t\t\t\t}\n\t\t\t},\n\t\t\tcontrolInterpolants: {\n\t\t\t\tget total() {\n\n\t\t\t\t\treturn scope._controlInterpolants.length;\n\n\t\t\t\t},\n\t\t\t\tget inUse() {\n\n\t\t\t\t\treturn scope._nActiveControlInterpolants;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\t// Memory management for AnimationAction objects\n\n\t_isActiveAction( action ) {\n\n\t\tconst index = action._cacheIndex;\n\t\treturn index !== null && index < this._nActiveActions;\n\n\t}\n\n\t_addInactiveAction( action, clipUuid, rootUuid ) {\n\n\t\tconst actions = this._actions,\n\t\t\tactionsByClip = this._actionsByClip;\n\n\t\tlet actionsForClip = actionsByClip[ clipUuid ];\n\n\t\tif ( actionsForClip === undefined ) {\n\n\t\t\tactionsForClip = {\n\n\t\t\t\tknownActions: [ action ],\n\t\t\t\tactionByRoot: {}\n\n\t\t\t};\n\n\t\t\taction._byClipCacheIndex = 0;\n\n\t\t\tactionsByClip[ clipUuid ] = actionsForClip;\n\n\t\t} else {\n\n\t\t\tconst knownActions = actionsForClip.knownActions;\n\n\t\t\taction._byClipCacheIndex = knownActions.length;\n\t\t\tknownActions.push( action );\n\n\t\t}\n\n\t\taction._cacheIndex = actions.length;\n\t\tactions.push( action );\n\n\t\tactionsForClip.actionByRoot[ rootUuid ] = action;\n\n\t}\n\n\t_removeInactiveAction( action ) {\n\n\t\tconst actions = this._actions,\n\t\t\tlastInactiveAction = actions[ actions.length - 1 ],\n\t\t\tcacheIndex = action._cacheIndex;\n\n\t\tlastInactiveAction._cacheIndex = cacheIndex;\n\t\tactions[ cacheIndex ] = lastInactiveAction;\n\t\tactions.pop();\n\n\t\taction._cacheIndex = null;\n\n\n\t\tconst clipUuid = action._clip.uuid,\n\t\t\tactionsByClip = this._actionsByClip,\n\t\t\tactionsForClip = actionsByClip[ clipUuid ],\n\t\t\tknownActionsForClip = actionsForClip.knownActions,\n\n\t\t\tlastKnownAction =\n\t\t\t\tknownActionsForClip[ knownActionsForClip.length - 1 ],\n\n\t\t\tbyClipCacheIndex = action._byClipCacheIndex;\n\n\t\tlastKnownAction._byClipCacheIndex = byClipCacheIndex;\n\t\tknownActionsForClip[ byClipCacheIndex ] = lastKnownAction;\n\t\tknownActionsForClip.pop();\n\n\t\taction._byClipCacheIndex = null;\n\n\n\t\tconst actionByRoot = actionsForClip.actionByRoot,\n\t\t\trootUuid = ( action._localRoot || this._root ).uuid;\n\n\t\tdelete actionByRoot[ rootUuid ];\n\n\t\tif ( knownActionsForClip.length === 0 ) {\n\n\t\t\tdelete actionsByClip[ clipUuid ];\n\n\t\t}\n\n\t\tthis._removeInactiveBindingsForAction( action );\n\n\t}\n\n\t_removeInactiveBindingsForAction( action ) {\n\n\t\tconst bindings = action._propertyBindings;\n\n\t\tfor ( let i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\tconst binding = bindings[ i ];\n\n\t\t\tif ( -- binding.referenceCount === 0 ) {\n\n\t\t\t\tthis._removeInactiveBinding( binding );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_lendAction( action ) {\n\n\t\t// [ active actions |  inactive actions  ]\n\t\t// [  active actions >| inactive actions ]\n\t\t//                 s        a\n\t\t//                  <-swap->\n\t\t//                 a        s\n\n\t\tconst actions = this._actions,\n\t\t\tprevIndex = action._cacheIndex,\n\n\t\t\tlastActiveIndex = this._nActiveActions ++,\n\n\t\t\tfirstInactiveAction = actions[ lastActiveIndex ];\n\n\t\taction._cacheIndex = lastActiveIndex;\n\t\tactions[ lastActiveIndex ] = action;\n\n\t\tfirstInactiveAction._cacheIndex = prevIndex;\n\t\tactions[ prevIndex ] = firstInactiveAction;\n\n\t}\n\n\t_takeBackAction( action ) {\n\n\t\t// [  active actions  | inactive actions ]\n\t\t// [ active actions |< inactive actions  ]\n\t\t//        a        s\n\t\t//         <-swap->\n\t\t//        s        a\n\n\t\tconst actions = this._actions,\n\t\t\tprevIndex = action._cacheIndex,\n\n\t\t\tfirstInactiveIndex = -- this._nActiveActions,\n\n\t\t\tlastActiveAction = actions[ firstInactiveIndex ];\n\n\t\taction._cacheIndex = firstInactiveIndex;\n\t\tactions[ firstInactiveIndex ] = action;\n\n\t\tlastActiveAction._cacheIndex = prevIndex;\n\t\tactions[ prevIndex ] = lastActiveAction;\n\n\t}\n\n\t// Memory management for PropertyMixer objects\n\n\t_addInactiveBinding( binding, rootUuid, trackName ) {\n\n\t\tconst bindingsByRoot = this._bindingsByRootAndName,\n\t\t\tbindings = this._bindings;\n\n\t\tlet bindingByName = bindingsByRoot[ rootUuid ];\n\n\t\tif ( bindingByName === undefined ) {\n\n\t\t\tbindingByName = {};\n\t\t\tbindingsByRoot[ rootUuid ] = bindingByName;\n\n\t\t}\n\n\t\tbindingByName[ trackName ] = binding;\n\n\t\tbinding._cacheIndex = bindings.length;\n\t\tbindings.push( binding );\n\n\t}\n\n\t_removeInactiveBinding( binding ) {\n\n\t\tconst bindings = this._bindings,\n\t\t\tpropBinding = binding.binding,\n\t\t\trootUuid = propBinding.rootNode.uuid,\n\t\t\ttrackName = propBinding.path,\n\t\t\tbindingsByRoot = this._bindingsByRootAndName,\n\t\t\tbindingByName = bindingsByRoot[ rootUuid ],\n\n\t\t\tlastInactiveBinding = bindings[ bindings.length - 1 ],\n\t\t\tcacheIndex = binding._cacheIndex;\n\n\t\tlastInactiveBinding._cacheIndex = cacheIndex;\n\t\tbindings[ cacheIndex ] = lastInactiveBinding;\n\t\tbindings.pop();\n\n\t\tdelete bindingByName[ trackName ];\n\n\t\tif ( Object.keys( bindingByName ).length === 0 ) {\n\n\t\t\tdelete bindingsByRoot[ rootUuid ];\n\n\t\t}\n\n\t}\n\n\t_lendBinding( binding ) {\n\n\t\tconst bindings = this._bindings,\n\t\t\tprevIndex = binding._cacheIndex,\n\n\t\t\tlastActiveIndex = this._nActiveBindings ++,\n\n\t\t\tfirstInactiveBinding = bindings[ lastActiveIndex ];\n\n\t\tbinding._cacheIndex = lastActiveIndex;\n\t\tbindings[ lastActiveIndex ] = binding;\n\n\t\tfirstInactiveBinding._cacheIndex = prevIndex;\n\t\tbindings[ prevIndex ] = firstInactiveBinding;\n\n\t}\n\n\t_takeBackBinding( binding ) {\n\n\t\tconst bindings = this._bindings,\n\t\t\tprevIndex = binding._cacheIndex,\n\n\t\t\tfirstInactiveIndex = -- this._nActiveBindings,\n\n\t\t\tlastActiveBinding = bindings[ firstInactiveIndex ];\n\n\t\tbinding._cacheIndex = firstInactiveIndex;\n\t\tbindings[ firstInactiveIndex ] = binding;\n\n\t\tlastActiveBinding._cacheIndex = prevIndex;\n\t\tbindings[ prevIndex ] = lastActiveBinding;\n\n\t}\n\n\n\t// Memory management of Interpolants for weight and time scale\n\n\t_lendControlInterpolant() {\n\n\t\tconst interpolants = this._controlInterpolants,\n\t\t\tlastActiveIndex = this._nActiveControlInterpolants ++;\n\n\t\tlet interpolant = interpolants[ lastActiveIndex ];\n\n\t\tif ( interpolant === undefined ) {\n\n\t\t\tinterpolant = new LinearInterpolant(\n\t\t\t\tnew Float32Array( 2 ), new Float32Array( 2 ),\n\t\t\t\t1, _controlInterpolantsResultBuffer );\n\n\t\t\tinterpolant.__cacheIndex = lastActiveIndex;\n\t\t\tinterpolants[ lastActiveIndex ] = interpolant;\n\n\t\t}\n\n\t\treturn interpolant;\n\n\t}\n\n\t_takeBackControlInterpolant( interpolant ) {\n\n\t\tconst interpolants = this._controlInterpolants,\n\t\t\tprevIndex = interpolant.__cacheIndex,\n\n\t\t\tfirstInactiveIndex = -- this._nActiveControlInterpolants,\n\n\t\t\tlastActiveInterpolant = interpolants[ firstInactiveIndex ];\n\n\t\tinterpolant.__cacheIndex = firstInactiveIndex;\n\t\tinterpolants[ firstInactiveIndex ] = interpolant;\n\n\t\tlastActiveInterpolant.__cacheIndex = prevIndex;\n\t\tinterpolants[ prevIndex ] = lastActiveInterpolant;\n\n\t}\n\n\t// return an action for a clip optionally using a custom root target\n\t// object (this method allocates a lot of dynamic memory in case a\n\t// previously unknown clip/root combination is specified)\n\tclipAction( clip, optionalRoot, blendMode ) {\n\n\t\tconst root = optionalRoot || this._root,\n\t\t\trootUuid = root.uuid;\n\n\t\tlet clipObject = typeof clip === 'string' ? AnimationClip.findByName( root, clip ) : clip;\n\n\t\tconst clipUuid = clipObject !== null ? clipObject.uuid : clip;\n\n\t\tconst actionsForClip = this._actionsByClip[ clipUuid ];\n\t\tlet prototypeAction = null;\n\n\t\tif ( blendMode === undefined ) {\n\n\t\t\tif ( clipObject !== null ) {\n\n\t\t\t\tblendMode = clipObject.blendMode;\n\n\t\t\t} else {\n\n\t\t\t\tblendMode = NormalAnimationBlendMode;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\tconst existingAction = actionsForClip.actionByRoot[ rootUuid ];\n\n\t\t\tif ( existingAction !== undefined && existingAction.blendMode === blendMode ) {\n\n\t\t\t\treturn existingAction;\n\n\t\t\t}\n\n\t\t\t// we know the clip, so we don't have to parse all\n\t\t\t// the bindings again but can just copy\n\t\t\tprototypeAction = actionsForClip.knownActions[ 0 ];\n\n\t\t\t// also, take the clip from the prototype action\n\t\t\tif ( clipObject === null )\n\t\t\t\tclipObject = prototypeAction._clip;\n\n\t\t}\n\n\t\t// clip must be known when specified via string\n\t\tif ( clipObject === null ) return null;\n\n\t\t// allocate all resources required to run it\n\t\tconst newAction = new AnimationAction( this, clipObject, optionalRoot, blendMode );\n\n\t\tthis._bindAction( newAction, prototypeAction );\n\n\t\t// and make the action known to the memory manager\n\t\tthis._addInactiveAction( newAction, clipUuid, rootUuid );\n\n\t\treturn newAction;\n\n\t}\n\n\t// get an existing action\n\texistingAction( clip, optionalRoot ) {\n\n\t\tconst root = optionalRoot || this._root,\n\t\t\trootUuid = root.uuid,\n\n\t\t\tclipObject = typeof clip === 'string' ?\n\t\t\t\tAnimationClip.findByName( root, clip ) : clip,\n\n\t\t\tclipUuid = clipObject ? clipObject.uuid : clip,\n\n\t\t\tactionsForClip = this._actionsByClip[ clipUuid ];\n\n\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\treturn actionsForClip.actionByRoot[ rootUuid ] || null;\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\t// deactivates all previously scheduled actions\n\tstopAllAction() {\n\n\t\tconst actions = this._actions,\n\t\t\tnActions = this._nActiveActions;\n\n\t\tfor ( let i = nActions - 1; i >= 0; -- i ) {\n\n\t\t\tactions[ i ].stop();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// advance the time and update apply the animation\n\tupdate( deltaTime ) {\n\n\t\tdeltaTime *= this.timeScale;\n\n\t\tconst actions = this._actions,\n\t\t\tnActions = this._nActiveActions,\n\n\t\t\ttime = this.time += deltaTime,\n\t\t\ttimeDirection = Math.sign( deltaTime ),\n\n\t\t\taccuIndex = this._accuIndex ^= 1;\n\n\t\t// run active actions\n\n\t\tfor ( let i = 0; i !== nActions; ++ i ) {\n\n\t\t\tconst action = actions[ i ];\n\n\t\t\taction._update( time, deltaTime, timeDirection, accuIndex );\n\n\t\t}\n\n\t\t// update scene graph\n\n\t\tconst bindings = this._bindings,\n\t\t\tnBindings = this._nActiveBindings;\n\n\t\tfor ( let i = 0; i !== nBindings; ++ i ) {\n\n\t\t\tbindings[ i ].apply( accuIndex );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// Allows you to seek to a specific time in an animation.\n\tsetTime( timeInSeconds ) {\n\n\t\tthis.time = 0; // Zero out time attribute for AnimationMixer object;\n\t\tfor ( let i = 0; i < this._actions.length; i ++ ) {\n\n\t\t\tthis._actions[ i ].time = 0; // Zero out time attribute for all associated AnimationAction objects.\n\n\t\t}\n\n\t\treturn this.update( timeInSeconds ); // Update used to set exact time. Returns \"this\" AnimationMixer object.\n\n\t}\n\n\t// return this mixer's root target object\n\tgetRoot() {\n\n\t\treturn this._root;\n\n\t}\n\n\t// free all resources specific to a particular clip\n\tuncacheClip( clip ) {\n\n\t\tconst actions = this._actions,\n\t\t\tclipUuid = clip.uuid,\n\t\t\tactionsByClip = this._actionsByClip,\n\t\t\tactionsForClip = actionsByClip[ clipUuid ];\n\n\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\t// note: just calling _removeInactiveAction would mess up the\n\t\t\t// iteration state and also require updating the state we can\n\t\t\t// just throw away\n\n\t\t\tconst actionsToRemove = actionsForClip.knownActions;\n\n\t\t\tfor ( let i = 0, n = actionsToRemove.length; i !== n; ++ i ) {\n\n\t\t\t\tconst action = actionsToRemove[ i ];\n\n\t\t\t\tthis._deactivateAction( action );\n\n\t\t\t\tconst cacheIndex = action._cacheIndex,\n\t\t\t\t\tlastInactiveAction = actions[ actions.length - 1 ];\n\n\t\t\t\taction._cacheIndex = null;\n\t\t\t\taction._byClipCacheIndex = null;\n\n\t\t\t\tlastInactiveAction._cacheIndex = cacheIndex;\n\t\t\t\tactions[ cacheIndex ] = lastInactiveAction;\n\t\t\t\tactions.pop();\n\n\t\t\t\tthis._removeInactiveBindingsForAction( action );\n\n\t\t\t}\n\n\t\t\tdelete actionsByClip[ clipUuid ];\n\n\t\t}\n\n\t}\n\n\t// free all resources specific to a particular root target object\n\tuncacheRoot( root ) {\n\n\t\tconst rootUuid = root.uuid,\n\t\t\tactionsByClip = this._actionsByClip;\n\n\t\tfor ( const clipUuid in actionsByClip ) {\n\n\t\t\tconst actionByRoot = actionsByClip[ clipUuid ].actionByRoot,\n\t\t\t\taction = actionByRoot[ rootUuid ];\n\n\t\t\tif ( action !== undefined ) {\n\n\t\t\t\tthis._deactivateAction( action );\n\t\t\t\tthis._removeInactiveAction( action );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst bindingsByRoot = this._bindingsByRootAndName,\n\t\t\tbindingByName = bindingsByRoot[ rootUuid ];\n\n\t\tif ( bindingByName !== undefined ) {\n\n\t\t\tfor ( const trackName in bindingByName ) {\n\n\t\t\t\tconst binding = bindingByName[ trackName ];\n\t\t\t\tbinding.restoreOriginalState();\n\t\t\t\tthis._removeInactiveBinding( binding );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// remove a targeted clip from the cache\n\tuncacheAction( clip, optionalRoot ) {\n\n\t\tconst action = this.existingAction( clip, optionalRoot );\n\n\t\tif ( action !== null ) {\n\n\t\t\tthis._deactivateAction( action );\n\t\t\tthis._removeInactiveAction( action );\n\n\t\t}\n\n\t}\n\n}\n\nexport { AnimationMixer };\n"],
  "mappings": "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",
  "names": []
}
